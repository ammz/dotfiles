#+TITLE: Configuración de Emacs
#+AUTHOR: Antonio Moreno (ammz)


* Emacs early-init.el
:PROPERTIES:
:header-args:emacs-lisp: :tangle ~/.config/emacs/early-init.el
:END:

Incrementa el límite antes de lanzar el recolector de basura para arrancar más rápido:

 #+begin_src emacs-lisp
  (setq gc-cons-threshold (* 200 1000 1000))
 #+end_src

Deshabilitamos toolbar, menubar y scrollbar

#+begin_src emacs-lisp
  (tool-bar-mode 0)
  (menu-bar-mode 0)
  (scroll-bar-mode 0)
#+end_src

Deshabilita que los paquetes instalados estén disponibles al arrancar

#+begin_src emacs-lisp
  (setq package-enable-at-startup nil)
#+end_src

No redimensiona la ventana cuando se cambia la fuente al inicio para evitar retraso:

#+begin_src emacs-lisp
  (setq frame-inhibit-implied-resize t)
  #+end_src

Configuración de la ventana de inicio

#+begin_src emacs-lisp
  (setq default-frame-alist
        (append
         (list
          '(undecorated . t)
          '(min-height . 1)
          '(height     . 42)
          '(min-width  . 1)
          '(width      . 170)
          '(vertical-scroll-bars . nil)
          '(internal-border-width . 10)
          '(tool-bar-lines . 0)
          '(menu-bar-lines . 0))))
#+end_src

Frame margin settings don't affect windows: in a vertical split, the text of the right window has no margin with the window edge on the left.
Therefore also set window margins for aesthetic consistency.

#+begin_src emacs-lisp
  (setq-default left-margin-width 1
                right-margin-width 1)
#+end_src

* Emacs init.el
:PROPERTIES:
:header-args:emacs-lisp: :tangle ~/.config/emacs/init.el
:END:

** Instalador de paquetes
*** Elpaca Package Manager

Esta sección viene al principio ya que el resto de secciones usarán =use-package= y =elpaca= para la gestión de paquetes

Se pueden hacer instalaciones de un solo uso (/ej/ para testar) con ~elpaca-try~.

#+begin_src emacs-lisp :results none
  (defvar elpaca-installer-version 0.7)
  (defvar elpaca-directory (expand-file-name "elpaca/" user-emacs-directory))
  (defvar elpaca-builds-directory (expand-file-name "builds/" elpaca-directory))
  (defvar elpaca-repos-directory (expand-file-name "repos/" elpaca-directory))
  (defvar elpaca-order '(elpaca :repo "https://github.com/progfolio/elpaca.git"
                                :ref nil :depth 1
                                :files (:defaults "elpaca-test.el" (:exclude "extensions"))
                                :build (:not elpaca--activate-package)))
  (let* ((repo  (expand-file-name "elpaca/" elpaca-repos-directory))
         (build (expand-file-name "elpaca/" elpaca-builds-directory))
         (order (cdr elpaca-order))
         (default-directory repo))
    (add-to-list 'load-path (if (file-exists-p build) build repo))
    (unless (file-exists-p repo)
      (make-directory repo t)
      (when (< emacs-major-version 28) (require 'subr-x))
      (condition-case-unless-debug err
          (if-let ((buffer (pop-to-buffer-same-window "*elpaca-bootstrap*"))
                   ((zerop (apply #'call-process `("git" nil ,buffer t "clone"
                                                   ,@(when-let ((depth (plist-get order :depth)))
                                                       (list (format "--depth=%d" depth) "--no-single-branch"))
                                                   ,(plist-get order :repo) ,repo))))
                   ((zerop (call-process "git" nil buffer t "checkout"
                                         (or (plist-get order :ref) "--"))))
                   (emacs (concat invocation-directory invocation-name))
                   ((zerop (call-process emacs nil buffer nil "-Q" "-L" "." "--batch"
                                         "--eval" "(byte-recompile-directory \".\" 0 'force)")))
                   ((require 'elpaca))
                   ((elpaca-generate-autoloads "elpaca" repo)))
              (progn (message "%s" (buffer-string)) (kill-buffer buffer))
            (error "%s" (with-current-buffer buffer (buffer-string))))
        ((error) (warn "%s" err) (delete-directory repo 'recursive))))
    (unless (require 'elpaca-autoloads nil t)
      (require 'elpaca)
      (elpaca-generate-autoloads "elpaca" repo)
      (load "./elpaca-autoloads")))
  (add-hook 'after-init-hook #'elpaca-process-queues)
  (elpaca `(,@elpaca-order))
#+end_src

=use-package= y =elpaca= se integran bien. Con =use-package-always-ensure= no hay que incluir =:ensure t= para que los paquetes se instalen si no lo están.

#+begin_src emacs-lisp :results none
  ;; Install use-package support
  (elpaca elpaca-use-package
    ;; Enable use-package :ensure support for Elpaca.
    (elpaca-use-package-mode)
    (setq use-package-always-ensure t))

  ;; Block until current queue processed.
  (elpaca-wait)
#+end_src

** Org mode

Usamos =noweb= (sintaxis =<<placeholder>>=) para poder referenciar a otros bloques para mejorar la claridad y organización de la configuración

#+BEGIN_SRC emacs-lisp :noweb no-export
  (use-package org
    :ensure nil
    :init (require 'org)
    :after ox
    :config
    <<org-config>>
    :bind
    ("C-c a" . org-agenda)
    ("C-c c" . org-capture)
    ("C-c b" . org-switchb)
    ("C-c t" . org-toggle-link-display)
    ("C-c l" . org-store-link)
    :hook
    (org-mode . visual-line-mode))
  (elpaca-wait)
#+END_SRC

*** Variables 

#+begin_src emacs-lisp :tangle no :noweb-ref org-config
  (setq org-startup-indented t         ;indentación de cabeceras
        org-list-allow-alphabetical t  ;listas numeradas alfabéticamente
        org-attach-use-inheritance t 
        org-ellipsis " »"
        org-startup-folded t   ;Inicio todo plegado
        org-hide-emphasis-markers t)   ;Oculta los marcadores de formato

  (setq-default org-fold-catch-invisible-edits 'smart)
#+end_src

*** Plantillas de captura

#+begin_src emacs-lisp :tangle no :noweb-ref org-config
  (setq org-capture-templates
        '(("o" "TODO vencimiento" entry
           (file+headline "~/Sync/org/inbox.org" "tareas")
           "* TODO %?\nDEADLINE: %^{fecha tope}t")
          ("t" "TODO" entry
           (file+headline "~/Sync/org/inbox.org" "tareas")
           "* TODO %?\n")
          ("n" "Nota" entry
           (file+headline "~/Sync/org/inbox.org" "notas")
           "* %?\n%c")
          ("h" "Nota alerta" entry
           (file+headline "~/proyectos/hugo-sge/content-org/pie.org" "notas de alerta")
           (function org-hugo-new-subtree-post-capture-template)
           :prepend t)
          ("r" "Recordatorio" entry
           (file "~/Sync/org/recuerda.org")
           "* %?\n %^t")
          ("d" "Diario" entry
           (file+olp+datetree "~/Sync/org/diario.org")
           "** %?" :time-prompt t)
          ("R" "Reunion" entry
           (file+headline "~/Sync/org/inbox.org" "reuniones")
           "* %? :reunion:\n%^t %^{lugar}p")
          ("i" "Informe" entry
           (file+headline "~/Sync/org/informes.org" "2019")
           "* TODO %? %^g\n:PROPERTIES:\n
                              :solicitante: %^{solicitante|sge|sgt|vice}\n
                              :f_entrada: %^u\n
                              :f_respuesta: \n:end:\n")))
#+end_src

*** Refile. Relocalización de los encabezamientos/tareas.

Scanea los target de refile en los archivos de la agenda. Aumenta los niveles en los que encontrar posibles encabezamientos para reasignar tareas. Por defecto son sólo 3.

#+begin_src emacs-lisp :tangle no :noweb-ref org-config
  (setq org-refile-targets (quote ((nil :maxlevel . 6)
                                   (org-agenda-files :maxlevel . 6))))
#+end_src

Establece como archivar los ficheros org

#+begin_src emacs-lisp :tangle no :noweb-ref org-config
  (setq org-archive-location "archivador/%s_archive::")
#+end_src

*** TODO

#+begin_src emacs-lisp :tangle no :noweb-ref org-config
  (setq org-todo-keywords
        '((sequence "TODO" "NEXT" "WAITING" "|" "DONE" "CANCEL")))
#+end_src

*** Exportación

#+begin_src emacs-lisp :tangle no :noweb-ref org-config
  (setq org-export-default-language "es")
  (setq org-export-date-timestamp-format "%d de %b %y")
  (setq org-export-allow-bind-keywords t)
#+end_src

*** icalendar

#+begin_src emacs-lisp :tangle no :noweb-ref org-config
  (setq org-icalendar-combined-agenda-file "/usr/local/var/www/org.ics")
  (setq org-icalendar-store-uid t)
  (setq org-icalendar-include-todo t)
  (setq org-icalendar-use-deadline '(event-if-todo))
  (setq org-icalendar-use-scheduled '(event-if-todo))
#+end_src

*** Bloques

#+begin_src emacs-lisp :tangle no :noweb-ref org-config
  (setq org-structure-template-alist
        '(("s" . "SRC")
          ("e" . "SRC emacs-lisp")
          ("E" . "EXAMPLE")
          ("q" . "QUOTE")
          ("v" . "VERSE")
          ("V" . "VERBATIM")
          ("c" . "CENTER")
          ("C" . "COMMENT")))

  (use-package org-tempo
    :ensure nil
    :init (require 'org-tempo))
#+end_src

*** Bloques de código

#+begin_src emacs-lisp :tangle no :noweb-ref org-config
  ;; Ejecuta bloques de código sin pedir confirmación
  (setq org-confirm-babel-evaluate nil)
  ;; Ejecuta los bloques de código al salvar el archivo
  (add-hook 'after-save-hook 'org-babel-tangle)
#+end_src

*** Lenguajes cargados para usar con org babel

#+begin_src emacs-lisp :tangle no :noweb-ref org-config
  (org-babel-do-load-languages
   'org-babel-load-languages
   '((emacs-lisp . t)
     (python . t)
     (shell . t)
     (ditaa . t)
     (calc . t)
     (lisp . t)
     (scheme . t)
     (haskell . t)
     (latex . t)
     (js . t)
     (makefile . t)
     (C . t)))
#+end_src

*** org link

#+begin_src emacs-lisp :tangle no :noweb-ref org-config
  (add-to-list 'org-file-apps '("\\.odt?\\'" . "xdg-open %s"))
  (add-to-list 'org-file-apps '("\\.ods?\\'" . "xdg-open %s"))
  (add-to-list 'org-file-apps '("\\.docx?\\'" . "xdg-open %s"))
#+end_src

*** Paquetes relacionados con org

#+begin_src emacs-lisp
  (use-package ob-async
    :after org)
#+end_src

#+begin_src emacs-lisp
  (use-package org-mac-link
    :after org)

  (add-hook 'org-mode-hook (lambda ()
                             (define-key org-mode-map
                                         (kbd "C-c g") 'org-mac-link-get-link)))
#+end_src


#+begin_src emacs-lisp
  (require 'org-inlinetask)
#+end_src

Permite utilizar la etiqueta 'ignore' para evitar exportar el encabezado pero no el contenido

#+begin_src emacs-lisp
  (use-package org-contrib
    :config
    (require 'ox-extra)
    (ox-extras-activate '(ignore-headlines)))
#+end_src

*** COMMENT Habilitamos org bullets

Org-bullets presenta unos puntos más atractivos que los simples asteriscos.

#+begin_src emacs-lisp
    (add-hook 'org-mode-hook 'org-indent-mode)
    (use-package org-bullets
      :after org)
    (add-hook 'org-mode-hook (lambda () (org-bullets-mode -1)))
#+end_src

*** Configuración de la Agenda

#+BEGIN_SRC emacs-lisp
  (setq org-agenda-files '("~/Sync/org/inbox.org"
                           "~/Sync/org/recuerda.org"
                           "~/Sync/org/comisiones.org"
                           "~/Sync/org/inf-obs.org"
                           "~/Sync/org/fci.org"))
  ;; agenda en la ventana actual
  (setq org-agenda-window-setup 'current-window)
  ;; avisa de tareas deadline en los próximos 7 días
  (setq org-deadline-warning-days 7)
  ;; muestra tareas scheduled o deadline en los próximos 10 días
  (setq org-agenda-span 10)
  ;; no muestra tareas scheduled si ya tienen fecha deadline
  (setq org-agenda-skip-deadline-if-deadlline-is-shown t)
  ;; no colorea tareas con deadline inminente si ya son scheduled
  (setq org-agenda-skip-deadline-prewarning-if-scheduled 'pre-scheduled)
  ;; no muestra tareas con fecha. implica que también ignora tareas
  ;; scheduled y deadlines
  (setq org-agenda-todo-ignore-with-date t)

  (setq org-agenda-custom-commands
        '(("h" "Agenda del día"
           ((agenda "" ((org-agenda-format-date "%a, %e %b %Y")))
            (alltodo "")))))
#+END_SRC

** Emacs server

Lo configuro al venir recomendado en los video de System Crafters sobre =EXWM=

#+BEGIN_SRC emacs-lisp
  (use-package server
    :ensure nil
    :init
    (server-start))
#+END_SRC

** EXWM

#+BEGIN_SRC emacs-lisp
  (use-package exwm
    :config
    ;; Set the initial workspace number.
    (setq exwm-workspace-number 5)

    ;; When a windows class is updated, make class name the buffer name
    (add-hook 'exwm-update-class-hook
              (lambda () (exwm-workspace-rename-buffer exwm-class-name)))
    (add-hook 'exwm-update-title-hook
              (lambda ()
                (when (or (not exwm-instance-name)
                          (string-prefix-p "sum-awt-x11-" exwm-instance-name)
                          (string= "gimp" exwm-instance-name))
                  (exwm-workspace-rename-buffer exwm-class-name))))

    ;; Global keybindings.
    (setq exwm-input-global-keys
          '(([?\s-&] . (lambda (command)
                         (interactive (list (read-shell-command "$ ")))
                         (start-process-shell-command command nil command)))

            ;; 's-r': Reset (to line-mode).
            ([?\s-r] . exwm-reset)

            ;; Bind 's-w' to switch to workspace interactively.
            ([?\s-w] . exwm-workspace-switch)

            ;; managing windows
            ([s-left] . windmove-left)
            ([s-right] . windmove-right)
            ([s-up] . windmove-up)
            ([s-down] . windmove-down)

            ;; swaping windows
            ([s-S-left] . windmove-swap-states-left)
            ([s-S-right] . windmove-swap-states-right)
            ([s-S-up] . windmove-swap-states-up)
            ([s-S-down] . windmove-swap-states-down)

            ;; managing window sizes
            ([s-M-left] . enlarge-window-horizontally)
            ([s-M-right] . shrink-window-horizontally)
            ([s-M-up] . shrink-window)
            ([s-M-down] . enlarge-window)

            ;; managing workspaces
            ;; ([?\M-0] . exwm-workspace--switch-map 0)
            ;; ([?\M-1] . exwm-workspace--switch-map 1)
            ;; ([?\M-2] . exwm-workspace--switch-map 2)

            ;; Focus window
            ([?\s- ] . other-window)
            ([?\s-1] . select-window-1)
            ([?\s-2] . select-window-2)
            ([?\s-3] . select-window-3)
            ([?\s-4] . select-window-4)
            ([?\s-5] . select-window-5)
            ([?\s-6] . select-window-6)
            ([?\s-7] . select-window-7)
            ([?\s-8] . select-window-8)))
            ;; ([s-f11] . ammz/go-previous-workspace)
            ;; ([s-f12] . ammz/go-next-workspace)

            ;;             `(,(kbd (format "s-%d" i)) .
            ;;               (lambda ()
            ;;                 (interactive)
            ;;                 (exwm-workspace-switch-create ,i))))
            ;;           (number-sequence 0 9))

            ;; Controles de audio
            ;; ([XF86AudioMute] . (lambda () (interactive) (start-process-shell-command "Mute" nil "amixer -q set Master toggle")))
            ;; ([XF86AudioLowerVolume] . (lambda () (interactive) (start-process-shell-command "Decrease" nil "amixer -q set Master 5%-")))
            ;; ([XF86AudioRaiseVolume] . (lambda () (interactive) (start-process-shell-command "Increase" nil "amixer -q set Master 5%+")))
            ;; ([XF86AudioPlay] . (lambda () (interactive) (start-process-shell-command "Play" nil "playerctl play-pause")))
            ;; ([XF86AudioNext] . (lambda () (interactive) (start-process-shell-command "Next" nil "playerctl next")))
            ;; ([XF86AudioPrev] . (lambda () (interactive) (start-process-shell-command "Previous" nil "playerctl previous")))
            ;; ([XF86AudioStop] . (lambda () (interactive) (start-process-shell-command "Stop" nil "playerctl stop")))

    (exwm-enable))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  ;; Enable exwm-randr before exwm-init (post-init setup) gets called
  (use-package exwm-randr
    :ensure nil
    ;; :if ammz/exwm-enabled
    :after (exwm)
    :config
    (setq exwm-randr-workspace-output-plist '(0 "eDP-1" 1 "DP-1"))
    (add-hook 'exwm-randr-screen-change-hook 'exwm-change-screen-hook)

    (add-hook 'exwm-randr-screen-change-hook
              (lambda ()
                (start-process-shell-command
                 "xrandr" nil "xrandr --dpi 108 --output eDP-1 --off --output DP-1 --auto")))

    (defun exwm-change-screen-hook ()
      (let ((xrandr-output-regexp "\n\\([^ ]+\\) connected ")
            default-output)
        (with-temp-buffer
          (call-process "xrandr" nil t nil)
          (goto-char (point-min))
          (re-search-forward xrandr-output-regexp nil 'noerror)
          (setq default-output (match-string 1))
          (forward-line)
          (if (not (re-search-forward xrandr-output-regexp nil 'noerror))
              (call-process "xrandr" nil nil nil "--output" default-output "--auto")
            (call-process
             "xrandr" nil nil nil
             "--dpi 108"
             "--output" (match-string 1) "--primary" "--auto"
             "--output" default-output "--off")
            (setq exwm-randr-workspace-output-plist (list 0 (match-string 1)))))))

    (exwm-randr-enable))
    #+END_SRC

*** Panel con Polybar

#+BEGIN_SRC emacs-lisp
  (defun ammz/run-in-background (command)
    (let ((command-parts (split-string command "[ ]+")))
      (apply #'call-process `(,(car command-parts) nil 0 nil ,@(cdr command-parts)))))
#+END_SRC

Aplicaciones que se ejecutan por detrás

#+BEGIN_SRC emacs-lisp
  (ammz/run-in-background "nm-applet")
  ;; (ammz/run-in-background "pasystray")
  ;; (ammz/run-in-background "blueman-applet")
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (defvar ammz/polybar-process nil
    "Guarda el proceso de la instancia Polybar que se ejecuta, si existe")

  (defun ammz/kill-panel ()
    (interactive)
    (when ammz/polybar-process
      (ignore-errors
        (kill-process ammz/polybar-process)))
    (setq ammz/polybar-process nil))

  (defun ammz/start-panel ()
    (interactive)
    (ammz/kill-panel)
    (setq ammz/polybar-process (start-process-shell-command "polybar" nil "polybar panel")))

  ;; Configura el escritorio en la primera carga
  (add-hook 'exwm-init-hook #'ammz/start-panel)
#+END_SRC

**** Obteniendo información desde Emacs

Es necesaio que emacs-server esté activado.

#+begin_example
  emacsclient -e "exwm-workspace-current-index"
#+end_example

Definimos una función para llamar a los workspaces que queramos.

#+BEGIN_SRC emacs-lisp
  (defun ammz/polybar-exwm-workspace ()
    "Devuelve el icono de un workspace"
    (pcase exwm-workspace-current-index
      (0 "")
      (1 "")
      (2 "")
      (3 "")
      (4 "")))
#+END_SRC

**** Enviando información desde Emacs usando hooks

Usamos el comando =polybar-msg= para invocar un "hook index" para tener el módulo actualizado por sí mismo

#+BEGIN_SRC sh
  polybar-msg hook exwm 1
#+END_SRC

Hay que documentarse sobre el módulo IPC en la wiki de Polybar: https://github.com/polybar/wiki/Module:-ipc

***** Invocamos el hook desde dentro de Emacs

#+BEGIN_SRC emacs-lisp
  (defun ammz/send-polybar-hook (module-name hook-index)
    "Envía mensajes a polybar de tipo Hook para los módulos custom/ipc)"
    (start-process-shell-command "polybar-msg" nil (format "polybar-msg hook %s %s" module-name hook-index)))

  (defun ammz/send-polybar-exwm-workspace ()
    (ammz/send-polybar-hook "exwm-workspace" 1))

  ;; Actualiza el indicador del planel cuando cambia el workspace
  (add-hook 'exwm-workspacee-switch-hook #'ammz/send-polybar-exwm-workspace)
#+END_SRC

** Configuración básica

Algunas variables a mi gusto.

*** Datos personales

Además de útil para la gestión del email, algunos modos pueden usar estos datos, como Org Mode.

#+BEGIN_SRC emacs-lisp
  (use-package startup
    :ensure nil
    :no-require t
    :custom
    (user-mail-address "antonio.moreno.m@juntadeandalucia.es")
    (user-full-name "Antonio Moreno"))
#+END_SRC

*** Directorio por defecto

#+BEGIN_SRC emacs-lisp
  ;; Directorio de inicio tras C-x C-f
  (setq default-directory "~/")
#+END_SRC

*** Actualiza el load-path

El directorio con el código lisp propio hay que incluirlo en el load-path.

#+BEGIN_SRC emacs-lisp
  (push "/Users/ammz/.config/emacs/lisp" load-path)
#+END_SRC

*** Backups

Colocamos los ficheros backup en un único directorio, en vez de estar repartidos por todas partes.

#+BEGIN_SRC emacs-lisp
  (use-package files
    :ensure nil
    :config
    (setq backup-directory-alist '(("." . "~/.config/emacs/backups/")))
    (setq create-lockfiles nil))
#+END_SRC

*** Más pequeños ajustes

- Responder solo con y/n
- Seguir enlaces sin preguntar
- Respuesta más rápida mostrando las combinaciones de teclas
- Permite ciertas acciones limitadas por Emacs
- Elimina los avisos sonoros
- No usar diálogos emergentes gráficos

#+BEGIN_SRC emacs-lisp
  (use-package emacs
    :ensure nil
    :init
    (setq frame-title-format '("%b -  %I"))
    (setq echo-keystrokes 0.25)           ; Muestra más rápido las combinaciones de teclas
    (setq auto-revert-verbose nil)        ; No muestra mensaje
    (setq ring-bell-function 'ignore)     ; Elimina los avisos sonoros
    (setq use-dialog-box nil)             ; Sin diálogos gráficos emergentes
  :config
    (defalias 'yes-or-no-p 'y-or-n-p)     ; Responder solo con y/n
    ;; Se permiten ciertas acciones limitadas por Emacs
    (put 'narrow-to-region 'disabled nil)
    (put 'upcase-region 'disabled nil)	; =C-x C-u=
    (put 'downcase-region 'disabled nil)	; =C-x C-l=
    (put 'dired-find-alternate-file 'disabled nil))
#+END_SRC

*** Custom.el

Almacenamos en un fichero separado el código elisp que Emacs añade al instalar algunos paquetes o usar los interfaces de configuración.

#+BEGIN_SRC emacs-lisp
  (use-package cus-edit
    :ensure nil
    :config
    (setq custom-file (expand-file-name "custom.el" user-emacs-directory))
    (unless (file-exists-p custom-file)
      (make-empty-file custom-file))
    (load custom-file 'noerror 'nomessage))
#+END_SRC

*** Registro del histórico
**** Recentf (ficheros y directorios recientes)

Este modo realiza un seguimiento de los ficheros que teníamos abiertos, permitiendo volver a ellos rápidamente.

#+BEGIN_SRC emacs-lisp
  (use-package recentf
    :ensure nil
    :config
    (setq recentf-save-file (expand-file-name "recentf" user-emacs-directory))
    (setq recentf-max-menu-items 10)
    (setq recentf-exclude '(".gz" ".xz" ".zip" "/elpa/" "/ssh:" "/sudo:"))
    :hook (after-init . recentf-mode))
#+END_SRC

**** Minibuffer

Mantiene un registro de las acciones del minibuffer

#+BEGIN_SRC emacs-lisp
  (use-package savehist
    :ensure nil
    :config
    (setq savehist-file (expand-file-name "savehist" user-emacs-directory))
    (setq savehist-save-minibuffer-history t)
    (setq history-length 25)
    (savehist-mode 1))
#+END_SRC

**** Posición del cursor

Recuerda donde están los /points/ en cualquier fichero.

#+BEGIN_SRC emacs-lisp
  (use-package saveplace
    :ensure nil
    :config
    (setq save-place-file (expand-file-name "saveplace" user-emacs-directory))
    (save-place-mode 1))
#+END_SRC

*** Selección

Este modo elimina la región marcada cuando se escribe directamente sobre ella.

#+BEGIN_SRC emacs-lisp
  (use-package delsel
    :ensure nil
    :hook (after-init . delete-selection-mode))
#+END_SRC

*** Refresca los buffers si cambian los ficheros

Emacs no refresca los buffers de un fichero cuando el fichero ha sido cambiado fuera de Emacs. Esto ocurre cuando se usan herramientas que generan algún tipo de fichero de texto que estamos leyendo en Emacs.

#+BEGIN_SRC emacs-lisp
  (use-package autorevert
    :ensure nil
    :config
    (global-auto-revert-mode 1)
    (setq global-auto-revert-non-file-buffers nil))
#+END_SRC

** Fuentes

#+begin_src emacs-lisp
  (let ((screen-width (x-display-pixel-width))
        (screen-height (x-display-pixel-height)))
    (if (>= screen-width 3840)
        (setq font-size 145)
      (setq font-size 95))
    (set-face-attribute 'default nil :family "Iosevka Comfy" :weight 'normal :height font-size))

  (set-face-attribute 'variable-pitch nil :family "Iosevka Comfy Motion Duo" :height 1.0)
  (set-face-attribute 'fixed-pitch nil :family "Iosevka Nerd Font" :height 1.0)
#+end_src

#+RESULTS:

** Configuración de la interfaz
*** Sin pantalla de inicio

Eliminamos la pantalla de Emacs muestra cuando se inicia sin un fichero.

#+BEGIN_SRC emacs-lisp
  (use-package startup
    :ensure nil
    :no-require t
    :config
    (setq inhibit-startup-screen t))
#+END_SRC

*** Mostramos las líneas con saltos por palabras

#+begin_src emacs-lisp
  (use-package startup
    :ensure nil
    :no-require t
    :config
    (global-visual-line-mode 1))
#+end_src

*** Números de líneas / Caracteres invisibles

#+BEGIN_SRC emacs-lisp
  (use-package emacs
    :ensure nil
    :config
    (defun prot/toggle-line-numbers ()
      "Toggles the display of line numbers.  Applies to all buffers."
      (interactive)
      (if (bound-and-true-p display-line-numbers-mode)
          (display-line-numbers-mode -1)
        (display-line-numbers-mode)))

    (defun prot/toggle-invisibles ()
      "Toggles the display of indentation and space characters."
      (interactive)
      (if (bound-and-true-p whitespace-mode)
          (whitespace-mode -1)
        (whitespace-mode)))
    :bind (("<f7>" . prot/toggle-line-numbers)
           ("<f8>" . prot/toggle-invisibles)))
#+END_SRC

*** Delimitadores resaltados

#+BEGIN_SRC emacs-lisp
  (use-package paren
    :ensure nil
    :config
    (show-paren-mode)
    :custom
    (show-paren-style 'mixed))
#+END_SRC

*** Configuración del modeline
**** Hora 

#+BEGIN_SRC emacs-lisp
  (use-package emacs
    :ensure nil
    :config
    (setq display-time-24hr-format t)
    (display-time))
#+END_SRC

**** Iconos

#+BEGIN_SRC emacs-lisp
  (use-package nerd-icons
    :custom
    ;; The Nerd Font you want to use in GUI
    ;; "Symbols Nerd Font Mono" is the default and is recommended
    ;; but you can use any other Nerd Font if you want
    (nerd-icons-font-family "Symbols Nerd Font Mono")
    )
#+END_SRC

**** doom-modeline

#+BEGIN_SRC emacs-lisp
  (use-package doom-modeline
    :init (doom-modeline-mode 1))
#+END_SRC

*** Cursor

Usamos el cursor tipo barra (|) en la ventana activa y el tipo hollow en las demás

#+BEGIN_SRC emacs-lisp
  (use-package emacs
    :ensure nil
    :config
    (setq-default cursor-type '(bar . 4))
    (setq-default cursor-face-highlight-mode 1)
    (setq-default cursor-in-non-selected-windows 'hollow)
    (setq x-stretch-cursor nil))
#+END_SRC

*** Manejo de las ventanas
**** Numeración de las ventanas

Numera las ventanas y podemos situarnos en ellas con Alt-<num>.

#+BEGIN_SRC emacs-lisp
  (use-package window-numbering
    :init
    (setq window-numbering-keymap
      (let ((map (make-sparse-keymap)))
        (define-key map (kbd "M-0") 'select-window-0)
        (define-key map (kbd "M-1") 'select-window-1)
        (define-key map (kbd "M-2") 'select-window-2)
        (define-key map (kbd "M-3") 'select-window-3)
        (define-key map (kbd "M-4") 'select-window-4)
        (define-key map (kbd "M-5") 'select-window-5)
        (define-key map (kbd "M-6") 'select-window-6)
        (define-key map (kbd "M-7") 'select-window-7)
        (define-key map (kbd "M-8") 'select-window-8)
        (define-key map (kbd "M-9") 'select-window-9)
        map))
    :config
    (window-numbering-mode))
#+END_SRC

**** winner: restaura la disposición de las ventanas

| C-c left  | winner-undo |
| C-c right | winner-redo |

#+BEGIN_SRC emacs-lisp
  (use-package winner
    :ensure nil
    :config (winner-mode))
#+END_SRC

**** Elimina las ventanas help

Cuando se abre una ventana con un buffer help es dificil eliminarla ya que el puntero se queda en la ventana que lo llama, prefiero cerrarla rápidamente con =q= después de consultarla.

#+BEGIN_SRC emacs-lisp
  (use-package help
    :ensure nil
    :custom (help-window-select t))
#+END_SRC

*** Modo concentración (olivetti)

#+BEGIN_SRC emacs-lisp
  (use-package olivetti)
#+END_SRC

** Tema
*** Modus Theme

Debemos cargarlo al final, ya que todas las variables que utilicemos para personalizar el tema deben ir antes de llamar a =load-theme= en el =init.el=. Esto se debe a que el tema toma valores de estas variables cuando se carga. También será necesario que recarguemos el tema después de modificar cualquier variable.

#+begin_src emacs-lisp
  (use-package emacs
    :ensure nil
    :init
    (setq modus-themes-mode-line '(accented borderless)
          modus-themes-region '(bg-only)
          modus-themes-fringes nil
          modus-themes-bold-constructs t
          modus-themes-italic-constructs t
          modus-themes-tabs-accented t
          modus-themes-paren-match '(bold intense)
          modus-themes-prompts '(bold intense) 
          modus-themes-org-blocks 'tinted-background
          modus-themes-scale-headings t
          modus-themes-headings
          '((1 . (rainbow overline background 1.05))
            (2 . (rainbow background 1.05))
            (3 . (rainbow bold 1.0))
            (4 . (rainbow 1.0))))
    :config
    (load-theme 'modus-vivendi t)
    :bind ("<f5>" . modus-themes-toggle))
#+end_src
** Email 

Gestiono el correo electrónico con =mu4e=. 

No se utiliza el gestor de paquetes =elpaca=, ya que al instarlar =mu= (con el gestor del SO) también se instala =mu4e=. Y la razón de esto es que =mu= y =mu4e= deben estar sincronizados.

#+BEGIN_SRC emacs-lisp
  (use-package mu4e 
    :ensure nil
    :config
    ;; This is set to 't' to avoid mail syncing issues when using mbsync
    (setq mu4e-change-filenames-when-moving t)

    ;; Refresh mail using isync every 10 minutes
    (setq mu4e-update-interval (* 10 60))
    (setq mu4e-get-mail-command "mbsync -a")
    (setq mu4e-maildir "~/.mail/junta")

    (setq mu4e-drafts-folder "/Drafts")
    (setq mu4e-sent-folder   "/Sent")
    (setq mu4e-trash-folder  "/Trash")

    (setq mu4e-maildir-shortcuts
          '((:maildir "/Inbox"     :key ?i)
            (:maildir "/Sent"      :key ?s)
            (:maildir "/Trash"     :key ?t)
            (:maildir "/Drafts"    :key ?d)))

    (setq mu4e-headers-fields
          '((:human-date . 12)
            (:flags . 10)
            (:from-or-to . 72)
            ;; (:mailing-list . 10)
            (:thread-subject)))

     (add-to-list 'mu4e-bookmarks
       ;; add bookmark for not trashed messages
       '( :name "Inbox"
          :key  ?m
          :query "maildir:/inbox AND NOT flag:trashed"))

    (defun ammz-mu4e-headers-function ()
      (visual-line-mode -1)
      (toggle-truncate-lines 1))

    :hook
    (mu4e-headers-mode . ammz-mu4e-headers-function)

    :custom
    (mu4e-use-fancy-chars t))
#+END_SRC


** Utilidades

*** Perspective

#+BEGIN_SRC emacs-lisp
  (use-package perspective
    :bind
    ("C-x C-b" . persp-list-buffers)
    ;; (consult-customize consult--source-buffer :hidden t :default nil)
    ;; (add-to-list 'consult-buffer-sources persp-consult-source)
    :custom
    (persp-mode-prefix-key (kbd "C-c M-p"))
    :init
    (persp-mode t))
#+END_SRC

*** Helpful

#+BEGIN_SRC emacs-lisp
  (use-package helpful
    :config
    ;; Note that the built-in `describe-function' includes both functions
    ;; and macros. `helpful-function' is functions only, so we provide
    ;; `helpful-callable' as a drop-in replacement.
    (global-set-key (kbd "C-h f") #'helpful-callable)
    (global-set-key (kbd "C-h v") #'helpful-variable)
    (global-set-key (kbd "C-h k") #'helpful-key)
    (global-set-key (kbd "C-h x") #'helpful-command)

    ;; Lookup the current symbol at point. C-c C-d is a common keybinding
    ;; for this in lisp modes.
    (global-set-key (kbd "C-c C-d") #'helpful-at-point)
    ;; Look up *F*unctions (excludes macros).
    ;;
    ;; By default, C-h F is bound to `Info-goto-emacs-command-node'. Helpful
    ;; already links to the manual, if a function is referenced there.
    (global-set-key (kbd "C-h F") #'helpful-function))
#+END_SRC

*** PDF View

#+BEGIN_SRC emacs-lisp
  (use-package pdf-tools
    :mode ("\\.pdf\\'" . pdf-view-mode)
    :magic ("%PDF" . pdf-view-mode))
#+END_SRC

Después hay que ejecutar =M-x pdf-tools-install= para que funcione.

*** Dired (gestor de ficheros)
**** Configuración base

#+BEGIN_SRC emacs-lisp
    (when (eq system-type 'darwin)
      (require 'ls-lisp)
      (setq insert-directory-program "/usr/local/bin/gls"))

    (use-package dired
      :ensure nil
      :config
      (setq dired-dwim-target t)
      (setq dired-listing-switches "-al --group-directories-first")
      :bind (:map dired-mode-map
                  ("b" . dired-up-directory))
      :hook (dired-mode . dired-hide-details-mode))
#+END_SRC

**** dired-subtree (navegación tipo árbol)

#+BEGIN_SRC emacs-lisp
  (use-package dired-subtree
    :after dired
    :bind (:map dired-mode-map
                ("<tab>" . dired-subtree-toggle)
                ("<S-tab>" . dired-subtree-remove)))
#+END_SRC

**** Visualización de los iconos

#+BEGIN_SRC emacs-lisp
  (use-package nerd-icons-dired
    :hook
    (dired-mode . nerd-icons-dired-mode))
#+END_SRC

*** Origami

#+BEGIN_SRC emacs-lisp
  (use-package origami
    :bind ("C-c o" . origami-toggle-node)
    :hook (python-mode . origami-mode))
#+END_SRC

*** htmlize

Conversor del texto del buffer en HTML. Permite que los bloques de código se coloreen cuando se exporta a HTML.

#+BEGIN_SRC emacs-lisp
  (use-package htmlize)
#+END_SRC

*** docker

#+BEGIN_SRC emacs-lisp
  (use-package dockerfile-mode)
#+END_SRC

** Métodos de completado
*** Vertico

#+BEGIN_SRC emacs-lisp
  (use-package vertico
    :demand t
    :config (vertico-mode 1))
#+END_SRC

*** Orderless

#+BEGIN_SRC emacs-lisp
  (use-package orderless
    :after vertico
    :config
    (setq completion-styles '(orderless basic partial-completion)
          completion-category-default nil))
#+END_SRC

*** Marginalia

#+BEGIN_SRC emacs-lisp
  (use-package marginalia
    :config
    ;; (setq marginalia-annotators
    ;;       '(marginalia-annotators-heavy
    ;;         marginalia-annotators-light))
    (marginalia-mode 1))
#+END_SRC

*** Consult

#+BEGIN_SRC emacs-lisp
  (use-package consult
    ;; :demand
    :config
    ;; (setq consult-line-numbers-widen t)
    (setq completion-in-region-function #'consult-completion-in-region)
    ;; (setq consult-async-input-debounce 0.5)
    ;; (setq consult-async-input-throttle 0.8)
    ;; (setq consult-narrow-key ">")
    ;; (setq consult-widen-key "<")
    :bind (("M-X" . consult-mode-command)
           ("M-y" . consult-yank-from-kill-ring)
           ("C-x b" . consult-buffer)
           ("M-s m" . consult-mark)
           :map consult-narrow-map
           ("?" . consult-narrow-help)
           :map minibuffer-local-completion-map
           ("<tab>" . minibuffer-force-complete)))
#+END_SRC

*** Embark

#+BEGIN_SRC emacs-lisp
  (use-package embark
    :bind
    (("C-." . embark-act)         ;; pick some comfortable binding
     ("C-;" . embark-dwim)        ;; good alternative: M-.
     ("C-h B" . embark-bindings)) ;; alternative for `describe-bindings'

    :init
    ;; Optionally replace the key help with a completing-read interface
    (setq prefix-help-command #'embark-prefix-help-command)

    :config
    ;; Hide the mode line of the Embark live/completions buffers
    (add-to-list 'display-buffer-alist
                 '("\\`\\*Embark Collect \\(Live\\|Completions\\)\\*"
                   nil
                   (window-parameters (mode-line-format . none)))))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  ;; Consult users will also want the embark-consult package.
  (use-package embark-consult
    :after (embark consult)
    :demand t ; only necessary if you have the hook below
    ;; if you want to have consult previews as you move around an
    ;; auto-updating embark collect buffer
    :hook
    (embark-collect-mode . consult-preview-at-point-mode))
#+END_SRC

*** Completado de expresiones

En Emacs podemos usar distintas formas para completar expresiones:
- =completion-at-point=: Es método nativo en Emacs
- =auto-complete=: disponible en MELPA.
- =company-mode=: 
- corfu: este es el usaremos

**** Corfu
#+BEGIN_SRC emacs-lisp
  (use-package corfu
   ;; Optional customizations
    :custom
    (corfu-cycle t)                ;; Enable cycling for `corfu-next/previous'
    (corfu-auto t)                 ;; Enable auto completion
    ;; (corfu-separator ?\s)          ;; Orderless field separator
    ;; (corfu-quit-at-boundary nil)   ;; Never quit at completion boundary
    ;; (corfu-quit-no-match nil)      ;; Never quit, even if there is no match
    ;; (corfu-preview-current nil)    ;; Disable current candidate preview
    ;; (corfu-preselect 'prompt)      ;; Preselect the prompt
    ;; (corfu-on-exact-match nil)     ;; Configure handling of exact matches
    ;; (corfu-scroll-margin 5)        ;; Use scroll margin

    ;; Enable Corfu only for certain modes. See also `global-corfu-modes'.
    ;; :hook ((prog-mode . corfu-mode)
    ;;        (shell-mode . corfu-mode)
    ;;        (eshell-mode . corfu-mode))

    ;; Recommended: Enable Corfu globally.  This is recommended since Dabbrev can
    ;; be used globally (M-/).  See also the customization variable
    ;; `global-corfu-modes' to exclude certain modes.
    :init
    (global-corfu-mode))
#+END_SRC


**** Cape
#+BEGIN_SRC emacs-lisp
  (use-package cape
    ;; Bind prefix keymap providing all Cape commands under a mnemonic key.
    ;; Press C-c p ? to for help.
    :bind ("C-c p" . cape-prefix-map) ;; Alternative keys: M-p, M-+, ...
    ;; Alternatively bind Cape commands individually.
    ;; :bind (("C-c p d" . cape-dabbrev)
    ;;        ("C-c p h" . cape-history)
    ;;        ("C-c p f" . cape-file)
    ;;        ...)
    :init
    ;; Add to the global default value of `completion-at-point-functions' which is
    ;; used by `completion-at-point'.  The order of the functions matters, the
    ;; first function returning a result wins.  Note that the list of buffer-local
    ;; completion functions takes precedence over the global list.
    (add-hook 'completion-at-point-functions #'cape-dabbrev)
    (add-hook 'completion-at-point-functions #'cape-keyword)
    (add-hook 'completion-at-point-functions #'cape-file)
    (add-hook 'completion-at-point-functions #'cape-elisp-block)
    ;; (add-hook 'completion-at-point-functions #'cape-history)
    ;; ...
  )
#+END_SRC
**** COMMENT Company mode

#+BEGIN_SRC emacs-lisp
  (use-package company
    :config
    (setq company-idle-delay 0.1
          company-minimum-prefix-length 1)
    :hook (after-init . global-company-mode))
#+END_SRC


** COMMENT Para tomar notas

#+BEGIN_SRC emacs-lisp
  (use-package denote
    :init
    (require 'denote-org-dblock)
    (denote-rename-buffer-mode 1)
    :custom
    (denote-directory "~/Sync/notas")
    :hook
    (dired-mode . denote-dired-mode)
    :custom-face
    (denote-faces-link ((t (:slant italic)))))

  ;; Denote extensions
  (use-package consult-notes
    :commands (consult-notes
               consult-notes-search-in-all-notes)
    :custom
    (consult-notes-file-dir-sources
     `(("Denote" ?d ,denote-directory))))
#+END_SRC

** Utilidades para programar
*** Magit (Interfaz para Git)

**** Transient

Librería que implementa los menús por teclado. Hay que actualizar la versión que viene por defecto en emacs para que funcione la instalación de Magit.

#+BEGIN_SRC emacs-lisp
  (use-package transient)
#+END_SRC

**** Magit

#+BEGIN_SRC emacs-lisp
  (use-package magit
    :bind ("C-x g" . magit-status)
    :after transient)
#+END_SRC

*** Edit server (edita formularios web en emacs)

#+BEGIN_SRC emacs-lisp
    (use-package edit-server)
#+END_SRC

*** Treesitter

#+BEGIN_SRC emacs-lisp

  (setq treesit-language-source-alist
        '((bash "https://github.com/tree-sitter/tree-sitter-bash")
          (cmake "https://github.com/uyha/tree-sitter-cmake")
          (c "https://github.com/tree-sitter/tree-sitter-c")
          (cpp "https://github.com/tree-sitter/tree-sitter-cpp")
          (css "https://github.com/tree-sitter/tree-sitter-css")
          (elisp "https://github.com/Wilfred/tree-sitter-elisp")
          (go "https://github.com/tree-sitter/tree-sitter-go")
          (html "https://github.com/tree-sitter/tree-sitter-html")
          (javascript "https://github.com/tree-sitter/tree-sitter-javascript" "master" "src")
          (json "https://github.com/tree-sitter/tree-sitter-json")
          (make "https://github.com/alemuller/tree-sitter-make")
          (markdown "https://github.com/ikatyang/tree-sitter-markdown")
          (python "https://github.com/tree-sitter/tree-sitter-python")
          (toml "https://github.com/tree-sitter/tree-sitter-toml")
          (tsx "https://github.com/tree-sitter/tree-sitter-typescript" "master" "tsx/src")
          (typescript "https://github.com/tree-sitter/tree-sitter-typescript" "master" "typescript/src")
          (typst "https://github.com/uben0/tree-sitter-typst")
          (yaml "https://github.com/ikatyang/tree-sitter-yaml")))

  (setq major-mode-remap-alist
        '((c-mode . c-ts-mode)
          (c++-mode . c++-ts-mode)))
          ;; (yaml-mode . yaml-ts-mode)
          ;; (bash-mode . bash-ts-mode)
          ;; (c-or-c++-mode . c-or-c++-ts-mode)
          ;; (js2-mode . js-ts-mode)
          ;; (typescript-mode . typescript-ts-mode)
          ;; (json-mode . json-ts-mode)
          ;; (css-mode . css-ts-mode)
          ;; (python-mode . python-ts-mode)))

#+END_SRC

*** COMMENT IDE (lsp)
**** COMMENT lsp-mode

#+BEGIN_SRC emacs-lisp

    (use-package emacs
      :config
      (setq lsp-clients-clangd-executable "/usr/local/opt/llvm/bin/clangd")
      (setq lsp-clients-clangd-args '("-j=4" "-background-index" "-log=info" "-pretty")))

    (defun efs/lsp-mode-setup ()
      (setq lsp-headerline-breadcrumb-segments '(path-up-to-project file symbols))
      (lsp-headerline-breadcrumb-mode))


    (use-package lsp-mode
      :straight t
      :commands (lsp lsp-deferred)
      :hook ((lsp-mode . efs/lsp-mode-setup)
             (clojure-mode . lsp)
             (clojurec-mode . lsp)
             (clojurescript-mode . lsp)
             (haskell-mode . lsp))
      :init
      (setq lsp-keymap-prefix "C-c l")
      :config
      (setq lsp-enable-which-key-integration t)
      ;; add paths to your local installation of project mgmt tools, like lein
      (setenv "PATH" (concat
                       "/usr/local/bin" path-separator
                       (getenv "PATH")))
      (dolist (m '(clojure-mode
                   clojurec-mode
                   clojurescript-mode
                   clojurex-mode))
         (add-to-list 'lsp-language-id-configuration `(,m . "clojure")))
      (setq lsp-clojure-server-command '("/usr/local/bin/clojure-lsp"))) ;; Optional: In case `clojure-lsp` is not in your $PATH

#+END_SRC

**** COMMENT lsp-ui

#+BEGIN_SRC emacs-lisp
  (use-package lsp-ui
    :straight t
    :hook (lsp-mode . lsp-ui-mode)
    :custom
    (lsp-ui-doc-position 'bottom))
#+END_SRC

**** COMMENT lsp-treemacs

#+BEGIN_SRC emacs-lisp
  (use-package lsp-treemacs
    :straight t
    :after lsp)
#+END_SRC

*** COMMENT Docker

#+BEGIN_SRC emacs-lisp
  (use-package dockerfile-mode)
  (use-package docker-compose-mode)
#+END_SRC

*** Herramientas de programación
**** Flycheck

#+BEGIN_SRC emacs-lisp
  (use-package flycheck
    :defer t)
  (add-hook 'prog-mode-hook 'flycheck-mode)
#+END_SRC

**** Projectile

#+BEGIN_SRC emacs-lisp
  (use-package projectile
    :config
    (define-key projectile-mode-map (kbd "C-c p") 'projectile-command-map))
#+END_SRC

*** COMMENT Debugging DAP mode

No es compatible con Eglot. (solo con LSP)


#+BEGIN_SRC emacs-lisp

  (use-package dap-mode
      :config
      (dap-auto-configure-mode)
      :bind
      (("<M-f7>" . dap-step-in)
       ("<M-f8>" . dap-next)
       ("<M-f9>" . dap-continue)))

  ;; (require 'dap-firefox)

#+END_SRC

*** COMMENT Debugging Dape

#+BEGIN_SRC emacs-lisp

(use-package dape)

#+END_SRC

*** COMMENT ESS

#+BEGIN_SRC emacs-lisp
  (use-package ess
    :straight t
    )
#+END_SRC

*** COMMENT Yasnippets

#+BEGIN_SRC emacs-lisp
  (use-package yasnippet
    :straight t
    :config
    (yas-reload-all)
    (yas-global-mode))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (use-package yasnippet-snippets
    :straight t)
#+END_SRC

*** COMMENT EditorConfig

#+BEGIN_SRC emacs-lisp
  (use-package editorconfig
    :straight t
    :config
    (editorconfig-mode 1))
#+END_SRC

** Relativo a los lenguajes
*** COMMENT C++

Modern C++ code highlighting

#+BEGIN_SRC emacs-lisp

  (use-package modern-cpp-font-lock
    :straight t
    :init
    (eval-when-compile
      ;; Silence missing function warnings
      (declare-function modern-c++-font-lock-global-mode
                        "modern-cpp-font-lock.el"))
    :config
    (modern-c++-font-lock-global-mode t)
    )

#+END_SRC

Cofiguramos cc-mode

#+BEGIN_SRC emacs-lisp
  (defvar my:compile-command "clang++ -std=c++20")
  (use-package cc-mode
    :init
    (add-to-list 'auto-mode-alist '("\\.tpp\\'" . c++-mode))
    (add-to-list 'auto-mode-alist '("\\.h\\'" . c++-mode))
    (add-to-list 'auto-mode-alist '("\\.hpp\\'" . c++-mode))
    (add-to-list 'auto-mode-alist '("\\.cpp\\'" . c++-mode))
    :config
    (define-key c++-mode-map (kbd "C-c C-c") 'compile)
    (define-key c++-mode-map (kbd "C-c C-k") 'kill-compilation)
    (setq compile-command my:compile-command)

    (use-package google-c-style
      :straight t
      :config
      ;; This prevents the extra two spaces in a namespace that Emacs
      ;; wise wants to put... Gawd!
      (add-hook 'c-mode-common-hook 'google-set-c-style)
      ;; Autoindent using google style guide
      (add-hook 'c-mode-common-hook 'google-make-newline-indent)
      )
    )
#+END_SRC

*** COMMENT Clojure

#+BEGIN_SRC emacs-lisp
  (use-package cider
    :straight t
    :init
    (setq cider-repl-display-help-banner nil)
    :config
    (add-hook 'cider-repl-mode-hook #'company-mode)
    (add-hook 'cider-mode-hook #'company-mode))
  (use-package clojure-mode
    :straight t)

#+END_SRC

*** COMMENT CSS

#+BEGIN_SRC emacs-lisp
  (use-package css-mode
    :config
    (setq css-fontify-colors nil))
#+END_SRC

*** COMMENT css / scss

#+BEGIN_SRC emacs-lisp
  (use-package sass-mode
    :straight t
    :mode ("\\.sass$" . sass-mode))
#+END_SRC

*** Ditaa

#+BEGIN_SRC emacs-lisp
  (setq org-ditaa-jar-path "/usr/share/java/ditaa/ditaa-0.11.jar")
#+END_SRC

*** COMMENT Django

#+BEGIN_SRC emacs-lisp
  (use-package lsp-pyright
    :hook (python-mode . (lambda ()
                           (require 'lsp-pyright)
                           (lsp))))  ; or lsp-deferred
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (use-package django-mode)
#+END_SRC

*** COMMENT Elm

#+BEGIN_SRC emacs-lisp
  (use-package elm-mode
    :straight t)
#+END_SRC

*** Haskell

#+BEGIN_SRC emacs-lisp

  (use-package haskell-mode)

  ;; (require 'haskell-interactive-mode)
  ;; (require 'haskell-process)
  ;; (setq haskell-process-type 'stack-ghci)
  ;; (require 'ob-haskell)
  ;; (add-hook 'haskell-mode-hook 'interactive-haskell-mode)
#+END_SRC

#+BEGIN_SRC emacs-lisp
  ;; (use-package lsp-haskell)
#+END_SRC

*** COMMENT Html

#+BEGIN_SRC emacs-lisp
  (use-package web-mode
    :straight t
    :mode ("\\.html$" . web-mode)
    :init (setq web-mode-markup-indent-offset 2))
#+END_SRC

Para previsualilzar en una navegador el buffer con html

#+BEGIN_SRC emacs-lisp
    (with-eval-after-load 'web-mode
      (define-key web-mode-map (kbd "C-c C-v") 'browse-url-of-buffer))
#+END_SRC

*** Hugo
**** Deshabilitando el caché

Esto es necesario para que funcione de forma fluida la exportación de ox-hugo. (recomendado en [[https://github.com/kaushalmodi/ox-hugo/discussions/551]])

#+BEGIN_SRC emacs-lisp
  (setq org-element-use-cache nil)
#+END_SRC

**** ox-hugo

#+BEGIN_SRC emacs-lisp
  (use-package ox-hugo
    :config
    (with-eval-after-load 'ox
      (require 'ox-hugo))
    )
#+END_SRC

***** COMMENT Plantilla para capturar nueva entrada

#+BEGIN_SRC emacs-lisp
  (defun org-hugo-new-subtree-post-capture-template ()
    "Returns `org-capture' template string for new Hugo post.
  See `org-capture-templates' for more information."
    (let* (;; http://www.holgerschurig.de/en/emacs-blog-from-org-to-hugo/
           (date (format-time-string (org-time-stamp-format :long :inactive) (org-current-time)))
           (title (read-from-minibuffer "Post Title: ")) ;Prompt to enter the post title
           (fname (org-hugo-slug title)))
      (mapconcat #'identity
                 `(
                   ,(concat "* " title)
                   ":PROPERTIES:"
                   ,(concat ":EXPORT_HUGO_BUNDLE: " fname)
                   ,(concat ":EXPORT_DATE: " date) ;Enter current date and time
                   ":END:"
                   "#+BEGIN_SRC yaml :front_matter_extra t"
                   "portada: 's'"
                   "resources:"
                   "  - src: "
                   "#+END_SRC"
                   "%?\n")                ;Place the cursor here finally
                 "\n")))
#+END_SRC

*** JavaScript

#+BEGIN_SRC emacs-lisp

  (setq js-indent-level 2)
  ;; (add-hook js-mode-hook #'eglot)

#+END_SRC
*** COMMENT Json

#+BEGIN_SRC emacs-lisp
  (use-package json-mode
    :straight t)
#+END_SRC

*** COMMENT Lisp
**** COMMENT slime

#+BEGIN_SRC emacs-lisp
  (use-package slime
    :config (setq inferior-lisp-program "sbcl"))
#+END_SRC

**** sly

#+BEGIN_SRC emacs-lisp
  (use-package sly
    :init
    (setq inferior-lisp-program "sbcl")
    (setq sly-default-lisp 'sbcl)
    (setq org-babel-lisp-eval-fn 'sly-eval))
#+END_SRC

*** COMMENT Lua

#+BEGIN_SRC emacs-lisp
  (use-package lua-mode
    :straight t)
#+END_SRC

*** Markdown

#+BEGIN_SRC emacs-lisp
  (use-package markdown-mode
    :config
    (setq markdown-fontify-code-blocks-natively t)
    :mode ("\\.md$" . markdown-mode))
#+END_SRC

*** COMMENT Ocaml

#+BEGIN_SRC emacs-lisp
  (use-package tuareg)
  (use-package dune)

  ;; Después de instalar merlin
  (let ((opam-share (ignore-errors (car (process-lines "opam" "var" "share")))))
    (when (and opam-share (file-directory-p opam-share))
      ;; Register Merlin
      (add-to-list 'load-path (expand-file-name "emacs/site-lisp" opam-share))
      (autoload 'merlin-mode "merlin" nil t nil)
      ;; Automatically start it in OCaml buffers
      (add-hook 'tuareg-mode-hook 'merlin-mode t)
      (add-hook 'caml-mode-hook 'merlin-mode t)
      ;; Use opam switch to lookup ocamlmerlin binary
      (setq merlin-command 'opam)
      ;; To easily change opam switches within a given Emacs session, you can
      ;; install the minor mode https://github.com/ProofGeneral/opam-switch-mode
      ;; and use one of its "OPSW" menus.
      ))

#+END_SRC

Configuración de algunas variables para su uso con OCaml y OPAM. Son el resultado de ejecutar =opam user-setup install=.

#+BEGIN_SRC emacs-lisp

  ;; Generic, recommended configuration options
  (custom-set-variables
   '(indent-tabs-mode nil)
   '(compilation-context-lines 2)
   '(compilation-error-screen-columns nil)
   '(compilation-scroll-output t)
   '(compilation-search-path (quote (nil "src")))
   '(electric-indent-mode nil)
   '(next-line-add-newlines nil)
   '(require-final-newline t)
   '(sentence-end-double-space nil)
   '(show-trailing-whitespace nil)
   '(visible-bell t)                      ; Fogonazos en vez del timbre
   ;; '(show-paren-mode t)                   ; Configurado específicamente
   '(next-error-highlight t)
   '(next-error-highlight-no-select t)
   '(backup-directory-alist '(("." . "~/.local/share/emacs/backups")))
   '(ac-use-fuzzy nil)
   '(line-move-visual t)
   )

  ;; ANSI color in compilation buffer
  (require 'ansi-color)
  (defun colorize-compilation-buffer ()
    (toggle-read-only)
    (ansi-color-apply-on-region (point-min) (point-max))
    (toggle-read-only))
  (add-hook 'compilation-filter-hook 'colorize-compilation-buffer)

  ;; Some key bindings

  ;; (global-set-key [f3] 'next-match)
  (defun prev-match () (interactive nil) (next-match -1))
  (global-set-key [(shift f3)] 'prev-match)
  (global-set-key [backtab] 'auto-complete)
  ;; OCaml configuration
  ;;  - better error and backtrace matching

  (defun set-ocaml-error-regexp ()
    (set
     'compilation-error-regexp-alist
     (list '("[Ff]ile \\(\"\\(.*?\\)\", line \\(-?[0-9]+\\)\\(, characters \\(-?[0-9]+\\)-\\([0-9]+\\)\\)?\\)\\(:\n\\(\\(Warning .*?\\)\\|\\(Error\\)\\):\\)?"
      2 3 (5 . 6) (9 . 11) 1 (8 compilation-message-face)))))

  (add-hook 'tuareg-mode-hook 'set-ocaml-error-regexp)
  (add-hook 'caml-mode-hook 'set-ocaml-error-regexp)
  ;; ## added by OPAM user-setup for emacs / base ## 56ab50dc8996d2bb95e7856a6eddb17b ## you can edit, but keep this line
  (require 'opam-user-setup "~/.config/emacs/opam-user-setup.el")
  ;; ## end of OPAM user-setup addition for emacs / base ## keep this line

#+END_SRC

**** COMMENT Todavía no comprobado
#+BEGIN_SRC emacs-lisp

  (use-package direnv
    :straight t)

  (use-package tuareg
    :straight t
    :mode ("\\.ocamlinit\\'" . tuareg-mode))

  (use-package dune
    :straight t)

  (use-package merlin
    :straight t
    :config
    (add-hook 'tuareg-mode-hook #'merlin-mode)
    (add-hook 'merlin-mode-hook #'company-mode)
    ;; we're using flycheck instead
    (setq merlin-error-after-save nil))

  (use-package merlin-eldoc
    :straight t
    :hook ((tuareg-mode) . merlin-eldoc-setup))

  ;; This uses Merlin internally
  (use-package flycheck-ocaml
    :straight t
    :config
    (add-hook 'tuareg-mode-hook
              (lambda ()
                ;; disable Merlin's own error checking
                (setq-local merlin-error-after-save nil)
                ;; enable Flycheck checker
                (flycheck-ocaml-setup))))

  (use-package utop
    :straight t
    :config
    (autoload 'utop "utop" "Toplevel for OCaml" t)
    (add-hook 'utop-mode-hook #'company-mode)
    (add-hook 'tuareg-mode-hook #'utop-minor-mode))

  ;; (let ((opam-share (ignore-errors (car (process-lines "opam" "var" "share")))))
  ;;   (when (and opam-share (file-directory-p opam-share))
  ;;     ;; Register Merlin
  ;;     (add-to-list 'load-path (expand-file-name "emacs/site-lisp" opam-share))
  ;;     (autoload 'merlin-mode "merlin" nil t nil)
  ;;     ;; Automatically start it in OCaml buffers
  ;;     (add-hook 'tuareg-mode-hook 'merlin-mode t)
  ;;     (add-hook 'caml-mode-hook 'merlin-mode t)
  ;;     ;; Use opam switch to lookup ocamlmerlin binary
  ;;    (setq merlin-command 'opam)))

  ;; (require 'ocp-indent)
  ;;
  ;; (use-package ocamlformat
  ;;   :custom (ocamlformat-enable 'enable-outside-detected-project)
  ;;   :hook (before-save . ocamlformat-before-save))

#+END_SRC

*** COMMENT Php

#+BEGIN_SRC emacs-lisp
  (use-package php-mode
    :straight t
    :mode ("\\.php$" . php-mode)
    :init
    (setq php-mode-coding-style (quote psr2))
    (setq php-search-documentation-browser-function 'eww-browse-url)
    (setq php-style-delete-trailing-whitespace 1)
    )
#+END_SRC

*** COMMENT Python

#+BEGIN_SRC emacs-lisp
  (use-package python-ts-mode
    :ensure nil
    :hook ((python-ts-mode . eglot-ensure)
           (python-ts-mode . company-mode))
    :bind (:map python-ts-mode-map
                ("<f9> . recompile")
                ("<f10> . eglot-format"))
    :mode (("\\.py\\'" . python-ts-mode)))
#+END_SRC

#+BEGIN_SRC emacs-lisp
    (use-package conda
      :config
      (setq conda-env-home-directory
            (expand-file-name "~/miniconda")))
#+END_SRC

*** COMMENT Python

La principal herramienta que uso para trabajar con python es Elpy.

#+BEGIN_SRC emacs-lisp
  (use-package elpy
    :defer
    :init
    (advice-add 'python-mode :before 'elpy-enable)
    ;; Se deshabilita flymake. Se usará flycheck.
    (remove-hook 'elpy-modules 'elpy-module-flymake))
#+END_SRC

*** COMMENT Racket

#+BEGIN_SRC emacs-lisp
  (use-package racket-mode
    :mode "\\.rkt\\'")
#+END_SRC

*** COMMENT Rust

#+BEGIN_SRC emacs-lisp
  (use-package rustic
    :config
    (setq rustic-format-on-save t
          rustic-cargo-bin-remote "/usr/local/cargo/bin/cargo"
          rustic-compile-command-remote "/usr/local/cargo/bin/cargo"
          rustic-rustfmt-bin-remote "/usr/local/cargo/bin/rustfmt"
          rustic-lsp-client 'eglot)
    :custom
    (add-to-list 'tramp-remote-path "/usr/local/perl/bin")
    (lsp-rust-analyzer-cargo-watch-command "clippy")
    (lsp-rust-analyzer-server-display-inlay-hints t)
    :mode ("\\.rs" . rustic-mode))
#+END_SRC

*** Scheme (variantes)

#+BEGIN_SRC emacs-lisp
  (require 'xscheme)
#+END_SRC

**** Guile

#+BEGIN_SRC emacs-lisp
  (use-package geiser-guile)
#+END_SRC

**** mit-scheme

#+BEGIN_SRC emacs-lisp
  (use-package geiser-mit)
#+END_SRC

*** COMMENT Sml

#+BEGIN_SRC emacs-lisp
  (use-package sml-mode
    :mode "\\.sml\\'")
#+END_SRC

*** COMMENT Typoscript

#+BEGIN_SRC emacs-lisp
  (use-package typoscript-mode
    :straight t
    :mode ("\\.typoscript" . typoscript-mode))
#+END_SRC

*** typst
#+BEGIN_SRC emacs-lisp

  (use-package typst-ts-mode
    :ensure (:host sourcehut :repo "meow_king/typst-ts-mode" :files (:defaults "*.el"))
    :custom
    (typst-ts-mode-watch-options "--open")
    ;; (optional) checking typst grammar version needs it
    (typst-ts-mode-grammar-location (expand-file-name "tree-sitter/libtree-sitter-typst.so" user-emacs-directory)))

#+END_SRC
*** YAML

#+BEGIN_SRC emacs-lisp
  (use-package yaml-mode
    :mode (("\\.yml$" . yaml-mode)
           ("\\.yaml$" . yaml-mode)))
#+END_SRC

** Calendario y agenda en español

#+BEGIN_SRC emacs-lisp
  (use-package emacs
    :ensure nil
    :config
    (setq system-time-locale "es_ES.UTF-8"))

  (use-package parse-time
    :ensure nil
    :defer t
    :config
    (setq parse-time-months 
          (append '(("ene" . 1) ("feb" . 2) ("mar" . 3)
                    ("abr" . 4) ("may" . 5) ("jun" . 6)
                    ("jul" . 7) ("ago" . 8) ("sep" . 9)
                    ("oct" . 10) ("nov" . 11) ("dic" . 12)
                    ("enero" . 1) ("febrero" . 2)
                    ("marzo" . 3) ("abril" . 4) ("junio" . 6)
                    ("julio" . 7) ("agosto" . 8)
                    ("septiembre" . 9) ("octubre" . 10)
                    ("noviembre" . 11) ("diciembre" . 12))
                  parse-time-months))
    (setq parse-time-weekdays
          (append '(("dom" . 0) ("lun" . 1) ("mar" . 2)
                    ("mié" . 3) ("jue" . 4) ("vie" . 5)
                    ("sáb" . 6) ("domingo" . 0) ("lunes" . 1)
                    ("martes" . 2) ("miércoles" . 3)
                    ("jueves" . 4) ("viernes" . 5)
                    ("sábado" . 6))
                  parse-time-weekdays)))

  (use-package calendar
    :ensure nil
    :custom
    (calendar-week-start-day 1)
    (calendar-day-name-array ["Domingo" "Lunes" "Martes" "Miércoles"
                              "Jueves" "Viernes" "Sábado"])
    (calendar-day-abbrev-array ["Dom" "Lun" "Mar" "Mié" "Jue" "Vie" "Sáb"])
    (calendar-day-header-array ["Do" "Lu" "Ma" "Mi" "Ju" "Vi" "Sá"])
    (calendar-month-name-array ["Enero" "Febrero" "Marzo" "Abril" "Mayo"
                                "Junio" "Julio" "Agosto" "Septiembre"
                                "Octubre" "Noviembre" "Diciembre"])
    (calendar-month-abbrev-array ["Ene" "Feb" "Mar" "Abr" "May" "Jun"
                                  "Jul" "Ago" "Sep" "Oct" "Nov" "Dic"]))
#+END_SRC




