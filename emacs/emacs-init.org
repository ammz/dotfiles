#+TITLE: Configuración de Emacs
#+AUTHOR: Antonio Moreno
#+PROPERTY: header-args :emacs-lisp :tangle ~/dotfiles/emacs/.emacs.d/init.el :results silent

* Sobre este documento

Este fichero contiene la documentación así como el código de la configuración de =Emacs=, que viene siendo la aplicación que más utilizo en el día a día (programación, gestión de tareas, escritos, ...).

Dado que vengo usando diferentes equipos y sistemas operativos (linux, mac), he decidido centralizar todas las configuraciones en este fichero.

Me he apoyado en distintas referencias. Las más usadas han sido:

- https://gitlab.com/andreyorst/dotfiles/-/blob/master/README.md
- https://gitlab.com/protesilaos/dotfiles/-/raw/master/emacs/.emacs.d/emacs-init.org
- https://github.com/daviwil/dotfiles/raw/master/Emacs.org

Para usar este fichero debemos descargarlo, preferiblemente, en =~/dotfiles/emacs/=, ejecutar =org-babel-tangle= y después reiniciar Emacs. Esta función exportará todo el código a distintos ficheros situados en =~/dotfiles/emacs/.emacs.d/=, según se indica con la propiedad =header-args= al principio del documento y bajo alguno de los encabezados.

** Dotfiles

Toda esta disposición de los ficheros es así por que uso =stow= y =git= para gestionar los /dotfiles/. Aclaro la terminologia:

- *package*: emacs
  Colección de ficheros y directorios de una aplicación que queremos administrar (Emacs)

- *stow directory*: =~/dotfiles=
  Directorio que contiene los paquetes en distintos subdirectorios.

- *target directory*: =~/=
  Es el directorio donde deben aparecer enlazados los ficheros

También guardo en el 'stow directory' los documentos /generadores/ =.org=, como éste mismo, que no se enlazarán pero que sí serán versionados con =git=. Para distinguirlos, he creado el fichero =~/.stow-global-ignore=, donde se excluyen los ficheros generadores =.org= y algunos otros.

Para utilizar este sistema en un equipo nuevo, lo primero sería clonar =dotfiles= y ejecutar el comando =stow= y el paquete que queramos. Por ejemplo,

#+begin_EXAMPLE sh

stow emacs

#+end_EXAMPLE

* =early-init.el=
:PROPERTIES:
:header-args+: :tangle "~/dotfiles/emacs/.emacs.d/early-init.el"
:END:

Aunque suelo tener funcionando Emacs todo el tiempo, hay veces que no. En esos casos siempre quiero que, cuando lo necesite, arranque lo más rápido posible.

A partir de Emacs 27, la inicilización del programa ha cambiado. Ahora todo lo que queramos hacer antes del arranque del programa lo tendremos que indicar en el fichero =early-init.el=. Por tanto, crearemos este fichero con algunas configuraciones.

Lo primero será comentar adecuadamente el fichero:

#+begin_src emacs-lisp
  ;;; early-init.el --- early configuration file -*- lexical-binding: t; buffer-read-only: t; no-byte-compile: t -*-
  ;;;
  ;;; Comentario:
  ;;; Configuración de Emacs de Antonio Moreno.
  ;;; Este fichero ha sido generado automáticamente con `org-babel-tangle'.
  ;;; No cambie este fichero. Fichero generador: emacs-init.org en `user-emacs-directory'
  ;;;
  ;;; Código:
#+end_src

Los ajustes iniciales:

** Recolector de basura

Aceleración del arranque ajustando el sistema de recolección de basura. Este sistema tiene un gran impacto en Emacs. Podemos espaciar el tiempo que tarda en activarse, pero esto repercutirá en el rendimiento cuando editemos. Por ello, solo lo ajustaremos durante el proceso de arranque. Almacenamos los valores iniciales para restaurarlos más tarde.

#+begin_SRC emacs-lisp

  (defvar ammz/gc-cons-threshold gc-cons-threshold) ;800000
  (defvar ammz/gc-cons-percentage gc-cons-percentage) ;0.1

#+end_SRC

Cambiamos el umbral (threshold) de activación.

#+begin_SRC emacs-lisp

  (setq-default gc-cons-threshold (* 50 1000 1000)
                gc-cons-percentage 0.6)

#+end_SRC

Por último, con un hook restauramos los valores iniciales

#+begin_SRC emacs-lisp

  (add-hook 'after-init-hook
            (lambda ()
              (setq gc-cons-threshold ammz/gc-cons-threshold)
              (setq gc-cons-percentage ammz/gc-cons-percentage)))

#+end_SRC

** Limpieza de la UI

Deshabilitamos algunos elementos de la interfaz gráfica lo antes posible para que no molesten. Sin embargo, mantengo el menubar con OS X.

#+begin_SRC emacs-lisp

  (unless (eq system-type 'darwin)		; Solo si no es Os X
    (menu-bar-mode -1))					; Deshabilita la menubar
  (scroll-bar-mode -1)					; Deshabilita la scrollbar
  (tool-bar-mode -1) 					; Deshabilita la toolbar

#+end_SRC

** Gestión de paquetes

*** =straight.el=

Para gestionar la instalación de paquetes uso =straight.el=, en vez de =package.el=. Éste instala paquetes desde los repositorios de Git listado en ELPA Y MELPA, o desde URL Git. Para instalarlo, según se indica en su [[https://github.com/raxod502/straight.el#getting-started][web]], primero debemos inicializarlo (bootstrap):

#+begin_SRC emacs-lisp

  (defvar bootstrap-version)
  (let ((bootstrap-file
         (expand-file-name "straight/repos/straight.el/bootstrap.el" user-emacs-directory))
        (bootstrap-version 5))
    (unless (file-exists-p bootstrap-file)
      (with-current-buffer
          (url-retrieve-synchronously
           "https://raw.githubusercontent.com/raxod502/straight.el/develop/install.el"
           'silent 'inhibit-cookies)
        (goto-char (point-max))
        (eval-print-last-sexp)))
    (load bootstrap-file nil 'nomessage))

#+end_SRC

*** =use-package=

Lo primero que instalamos y configuramos es =use-package=. Más tarde lo cargaremos.

#+begin_SRC emacs-lisp

  (straight-use-package 'use-package)

  ;; Configure `use-package' prior to loading it.
  (eval-and-compile
    (setq use-package-always-ensure nil)  ; ESSENTIAL for `straight.el'
    (setq use-package-always-defer nil)
    (setq use-package-always-demand nil)
    (setq use-package-expand-minimally nil)
    (setq use-package-enable-imenu-support t)
    (setq use-package-compute-statistics nil)
    ;; The following is VERY IMPORTANT.  Write hooks using their real name
    ;; instead of a shorter version: after-init ==> `after-init-hook'.
    ;;
    ;; This is to empower help commands with their contextual awareness,
    ;; such as `describe-symbol'.
    (setq use-package-hook-name-suffix nil))
#+end_SRC

** =(provide 'early-init)=
Aquí finaliza el fichero =early-init.el=.

#+begin_src emacs-lisp
  (provide 'early-init)
  ;;; early-init.el ends here
#+end_src


* Inicio del =init.el=

#+begin_src emacs-lisp
  ;;; init.el --- Emacs main configuration file -*- lexical-binding: t; buffer-read-only: t; no-byte-compile: t -*-
  ;;;
  ;;; Comentario:
  ;;; Configuración de Emacs de Antonio Moreno.
  ;;; Este fichero ha sido generado automáticamente con `org-babel-tangle'.
  ;;; No cambie este fichero. Fichero generador: emacs-init.org en `user-emacs-directory'
  ;;;
  ;;; Código:
#+end_src

* =use-package=

Este paquete facilita la instalación, carga y configuración de los /paquetes/ (incluyendo las librerías que vienen con Emacs). Este paquete ya debería estar instalado con =straight.el=. Solo nos queda /requerirlo/:

#+begin_SRC emacs-lisp

  (require 'use-package)

#+end_SRC

* Configuración básica

Algunas variables a mi gusto.

** Datos personales

Además de útil para la gestión del email, algunos modos pueden usar estos datos, como Org Mode.

#+begin_src emacs-lisp
  (use-package startup
    :no-require t
    ;; :straight nil
    :custom
    (user-mail-address "ammz@deversorius.net")
    (user-full-name "Antonio Moreno"))
#+end_src

** Directorio por defecto

#+begin_SRC emacs-lisp

  ;; Directorio de inicio tras C-x C-f
  (setq default-directory "~/")

#+end_SRC

** Actualiza el load-path

El directorio con el código lisp propio hay que incluirlo en el load-path.

#+begin_SRC emacs-lisp
(push "~/.emacs.d/lisp" load-path)
#+end_SRC

** Backups

Colocamos los ficheros backup en un único directorio, en vez de estar repartidos por todas partes.

#+begin_src emacs-lisp

  (use-package files
    ;; :straight nil
    :config
    (setq backup-directory-alist '(("." . "~/.emacs.d/backups/")))
    (setq create-lockfiles nil))

#+END_SRC

** Más pequeños ajustes

- Responder solo con y/n
- Seguir enlaces sin preguntar
- Respuesta más rápida mostrando las combinaciones de teclas
- Permite ciertas acciones limitadas por Emacs
- Elimina los avisos sonoros

#+begin_src emacs-lisp

  (use-package emacs
    :init
    (setq frame-title-format '("%b -  %I"))
    (setq echo-keystrokes 0.25)				; Muestra más rápido las combinaciones de teclas
    (setq auto-revert-verbose nil)				; No muestra mensaje
    (setq ring-bell-function 'ignore)			; Elimina los avisos sonoros
    :config
    (defalias 'yes-or-no-p 'y-or-n-p)		; Responder solo con y/n
    ;; Se permiten ciertas acciones limitadas por Emacs
    (put 'narrow-to-region 'disabled nil)
    (put 'upcase-region 'disabled nil)	; =C-x C-u=
    (put 'downcase-region 'disabled nil)	; =C-x C-l=
    (put 'dired-find-alternate-file 'disabled nil))

#+end_SRC

** Custom.el

Almacenamos en un fichero separado el código elisp que Emacs añade al instalar algunos paquetes o usar los interfaces de configuración.

#+begin_src emacs-lisp

  (use-package cus-edit
    ;; :straight nil
    :config
    (setq custom-file (expand-file-name "custom.el" user-emacs-directory))
    (unless (file-exists-p custom-file)
      (make-empty-file custom-file))
    (load custom-file))

#+end_src

** Registro del histórico
*** Recentf (ficheros y directorios recientes)

Este modo realiza un seguimiento de los ficheros que teníamos abiertos, permitiendo volver a ellos rápidamente.

#+begin_src emacs-lisp

  (use-package recentf
    :config
    (setq recentf-save-file (expand-file-name "recentf" user-emacs-directory))
    (setq recentf-max-menu-items 10)
    (setq recentf-exclude '(".gz" ".xz" ".zip" "/elpa/" "/ssh:" "/sudo:"))
    :hook (after-init-hook . recentf-mode))

#+end_src

*** Minibuffer

Mantiene un registro de las acciones del minibuffer

#+begin_src emacs-lisp

  (use-package savehist
    :config
    (setq savehist-file (expand-file-name "savehist" user-emacs-directory))
    (setq savehist-save-minibuffer-history t)
    (savehist-mode 1))

#+end_src

*** Posición del cursor

Recuerda donde están los /points/ en cualquier fichero.

#+begin_src emacs-lisp

  (use-package saveplace
    :config
    (setq save-place-file (expand-file-name "saveplace" user-emacs-directory))
    (save-place-mode 1))

#+END_SRC

** Selección

Este modo elimina la región marcada cuando se inserta directamente sobre ella.

#+begin_src emacs-lisp

  (use-package delsel
    :hook (after-init-hook . delete-selection-mode))

#+end_SRC

* Mejorando la estética

** Sin pantalla de inicio

Eliminamos la pantalla de Emacs muestra cuando se inicia sin un fichero.

#+begin_SRC emacs-lisp
  (use-package startup
    :no-require t
    ;; :straight nil
    :config
    (setq inhibit-startup-screen t))
#+end_SRC


#+BEGIN_SRC emacs-lisp

  (use-package emacs
    :config
    (set-fringe-mode 10))				; Give some breathing room

#+END_SRC

** Cursor

Usamos el cursor tipo barra (|) en la ventana activa y el tipo hollow en las demás

#+begin_src emacs-lisp

  (use-package emacs
    :config
    (setq cursor-type 'bar)
    (setq cursor-in-non-selected-windows 'hollow)
    (setq x-stretch-cursor nil))

#+end_SRC

** Tipo de letra

#+begin_src emacs-lisp

  (use-package emacs
    :config
    ;; (set-frame-font "Hack 12" t t)
    (set-face-attribute 'default nil :font "Hack 14"))

#+end_src

** Configuración del modeline

*** Lighters

El nombre de un modo en el modeline se denomina 'lighter'. Con este paquete se puede editar, renombrar u ocultar éstos. (la información aún estará disponible ejecutando =C-h m=). Además, la funcionalidad puede integrarse en la declaración de cada paquete de =use-package=: etiqueta =:delight=.

#+begin_SRC emacs-lisp

(use-package delight
  :straight t
  :after use-package)

#+end_SRC

*** Iconos y doom-modeline

  #+begin_SRC emacs-lisp

  (use-package all-the-icons
    :straight t
    :if (display-graphic-p)
    :commands all-the-icons-install-fonts
    :init
    (unless (find-font (font-spec :name "all-the-icons"))
      (all-the-icons-install-fonts t)))

  (use-package all-the-icons-dired
    :disabled
    :straight t
    :if (display-graphic-p)
    :hook (dired-mode-hook . all-the-icons-dired-mode))

  (use-package doom-modeline
    :straight t
    :init (doom-modeline-mode 1))

  #+end_SRC

** Temas

*** Material

#+begin_SRC emacs-lisp

  (use-package material-theme
    :straight t)

  (load-theme 'material t)

#+end_SRC

*** Doom

#+begin_SRC emacs-lisp

  (use-package doom-themes
    :disabled
    :straight t)

#+end_SRC

*** COMMENT Modus

#+BEGIN_SRC emacs-lisp

  ;;versión oscura
  (use-package modus-vivendi-theme
    :straight t)

  ;;versión clara
  (use-package modus-operandi-theme
    :straight t)

  (use-package emacs
    :config
    (defun ammz/modus-operandi ()
      (load-theme 'modus-operandi t))

    (defun ammz/modus-vivendi ()
      (load-theme 'modus-vivendi t))

    (defun ammz/modus-themes-toggle ()
      "Simplistic toggle for my Modus Themes.  All it does is check
     if `modus-operandi' (light version) is active and if so switch to
     `modus-vivendi' (dark version).  Else it switches to the light
     theme."
      (interactive)
      (if (eq (car custom-enabled-themes) 'modus-operandi)
          (ammz/modus-vivendi)
        (ammz/modus-operandi)))
    :bind ("<f5>" . ammz/modus-themes-toggle)
    :hook (after-init-hook . ammz/modus-operandi))

#+end_SRC

** Números de líneas

Por defecto, activamos los números de líneas en todos los modos. No obstante, lo desactivamos en algunos como org-mode, dired y las terminales.

#+begin_SRC emacs-lisp

  (use-package display-line-numbers
    :config
    (column-number-mode)
    (setq global-display-line-numbers-mode t)
    (setq display-line-numbers-grow-only t)
    ;; Deshabilita los números de línea en algunos modos
    (dolist (mode '(org-mode-hook
                    term-mode-hook
				    dired-mode-hook
                    shell-mode-hook
                    eshell-mode-hook))
      (add-hook mode (lambda () (display-line-numbers-mode 0)))))

#+end_SRC

** Específico para OS X

Configuración del teclado en OS X

#+BEGIN_SRC emacs-lisp

  (when (eq system-type 'darwin)
    (setq ns-pop-up-frames t)
    (setq ns-function-modifier (quote super))
    (setq ns-alternate-modifier (quote meta))
    (setq ns-command-modifier (quote control))
    (setq ns-control-modifier (quote super))
    (setq ns-right-command-modifier (quote meta))
    (setq ns-right-alternate-modifier (quote none))
    ;; Esta configuración funciona con la versión de emacs (Emacs Plus):
    ;; https://github.com/d12frosted/homebrew-emacs-plus#emacs-configuration
    ;; También es necesario configurar el teclado con 'Karabiner-elements'
    (setq mac-pass-command-to-system nil)	;command-h no se gestiona por OS X
    (setq mac-command-modifier 'control)
    (setq mac-right-command-modifier 'meta)
    (setq mac-option-modifier 'meta)
    (setq mac-right-option-modifier '(:function alt :mouse alt)))

#+End_SRC

En OS X, Emacs no toma algunas variables de entorno si no se inicia desde el shell. Vamos a corregirlo.

#+BEGIN_SRC emacs-lisp

  (use-package exec-path-from-shell
    :straight t
    :if (memq window-system '(mac ns x))
    :init
    (setq exec-path-from-shell-check-startup-files nil)
    ;; Ampliamos las variables que coge por defecto
    (exec-path-from-shell-copy-envs '("LANG" "WORKON_HOME"))
    :config
    (exec-path-from-shell-initialize))

#+END_SRC

* Manejo de las ventanas

** winner: restaura la disposición de las ventanas

| C-c left  | winner-undo |
| C-c right | winner-redo |

#+begin_SRC emacs-lisp

  (use-package winner
      :config (winner-mode))

#+end_SRC

** Elimina las ventanas help

Cuando se abre una ventana con un buffer help es dificil eliminarla ya que el puntero se queda en la ventana que lo llama, prefiero cerrarla rápidamente con =q= después de consultarla.

#+begin_src emacs-lisp
  (use-package help
    :straight nil
    :custom (help-window-select t))
#+end_src

** Numeración de las ventanas

Numera las ventanas y podemos situarnos en ellas con Alt-<num>.

#+begin_src emacs-lisp

  (use-package window-numbering
    :straight t
    :config
    (window-numbering-mode))

#+end_src

* Herramientas

** Focus

#+begin_SRC emacs-lisp

  (use-package visual-fill-column
    :straight t)

  (defun ammz/org-mode-visual-fill ()
    (setq visual-fill-column-width 100
          visual-fill-column-center-text t)
    (visual-fill-column-mode 1))

  (use-package visual-fill-column
    :hook
    (org-mode-hook . ammz/org-mode-visual-fill)
    (ConTeXt-mode-hook . ammz/org-mode-visual-fill))

#+end_SRC

** Emacs server

Permite que =emacsclient= (con o sin =--create-frame=) comparta el proceso de ejecución de emacs. El servidor persistirá mientras exista un frame asociado a dicho servidor.

#+begin_src emacs-lisp

  (use-package server
    :hook (after-init-hook . server-start))

#+end_src

** Comentarios

#+begin_src emacs-lisp

  (use-package newcomment
    :config
    (setq comment-empty-lines t)
    (setq comment-multi-line t)
    (setq comment-style 'multi-line)
    :bind ("C-;" . comment-dwim)
    )

#+end_SRC
** Origami - Plegado de código

Origami - Does code folding, ie hide the body of an if/else/for/function so that you can fit more code on your screen

#+begin_src emacs-lisp

  (use-package origami
    :straight t
    :commands (origami-mode)
    :bind (:map origami-mode-map
                ("C-c o o" . origami-recursively-toggle-node)
                ("C-c o a" . origami-toggle-all-nodes)
                ("C-c o t" . origami-toggle-node)
                ("C-c o :" . origami-show-only-node)
                ("C-c o u" . origami-undo)
                ("C-c o U" . origami-redo)
                ("C-c o C-r" . origami-reset)
                )
    :config
    (setq origami-show-fold-header t)
    ;; The python parser currently doesn't fold if/for/etc. blocks, which is
    ;; something we want. However, the basic indentation parser does support
    ;; this with one caveat: you must toggle the node when your cursor is on
    ;; the line of the if/for/etc. statement you want to collapse. You cannot
    ;; fold the statement by toggling in the body of the if/for/etc.
    (add-to-list 'origami-parser-alist '(python-mode . origami-indent-parser))
    :init
    (add-hook 'prog-mode-hook 'origami-mode)
    )

#+end_SRC

** Dired (gestor de ficheros)
*** Configuración base

#+begin_src emacs-lisp
  (when (eq system-type 'darwin)
    (require 'ls-lisp)
    (setq insert-directory-program "/usr/local/bin/gls"))

  (use-package dired
    ;; :custom ((dired-listing-switches "-agho --group-directories-first"))
    :bind (:map dired-mode-map
                ("b" . dired-up-directory)))

#+end_SRC

*** dired-subtree (navegación tipo árbol)

#+begin_src emacs-lisp

  (use-package dired-subtree
    :straight t
    :after dired
    :bind (:map dired-mode-map
                ("<tab>" . dired-subtree-toggle)
                ("<S-tab>" . dired-subtree-remove)))

#+end_SRC
** Magit (Interfaz para Git)

#+begin_src emacs-lisp

  (use-package magit
    :straight t
    :bind (("C-c g" . magit-status)))

#+END_SRC

El siguiente paquete está configurado conforme la guía de este artículo [[https://chris.beams.io/posts/git-commit/][Writing a Git commit message]].

#+begin_src emacs-lisp

  (use-package git-commit
    :after magit
    :custom
    (git-commit-fill-column 72)
    (git-commit-summary-max-length 50)
    (git-commit-known-pseudo-headers
     '("Signed-off-by"
       "Acked-by"
       "Modified-by"
       "Cc"
       "Suggested-by"
       "Reported-by"
       "Tested-by"
       "Reviewed-by"))
    (git-commit-style-convention-checks
     '(non-empty-second-line
       overlong-summary-line)))

#+END_SRC

La siguiente configuración es para las pantallas diff que produce Magit.

#+begin_src emacs-lisp

  (use-package magit-diff
    :after magit
    :custom
    (magit-diff-refine-hunk t))

#+END_SRC
** Trabajando con buffers

Estos ajustes facilitan trabajar con múltiples buffers. Cuando tienen el mismo nombre, Emacs procurará diferenciarlos mostrando su ruta entre ángulos, mientras quita la parte que tienen en común.

Todas estas operaciones se revierten cuando un buffer se quita de la lista de afectados.

#+begin_src emacs-lisp

  (use-package uniquify
    :custom
    (uniquify-buffer-name-style 'post-forward-angle-brackets)
    (uniquify-strip-common-suffix t)
    (uniquify-after-kill-buffer-p t))

#+END_SRC

*** Configuración de ibuffer

#+begin_src emacs-lisp

  (use-package ibuffer
    :custom
    (ibuffer-expert t)
    (ibuffer-display-summary nil)
    (ibuffer-use-other-window nil)
    (ibuffer-show-empty-filter-groups nil)
    (ibuffer-movement-cycle nil)
    (ibuffer-default-sorting-mode 'filename/process)
    ;;;; NOTE built into the Modus themes
    ;; (ibuffer-deletion-face 'dired-flagged)
    ;; (ibuffer-marked-face 'dired-marked)
    (ibuffer-saved-filter-groups
     '(("Main"
        ("Directories" (mode . dired-mode))
        ("Org" (mode . org-mode))
        ("Programming" (or
                        (mode . c-mode)
                        (mode . conf-mode)
                        (mode . css-mode)
                        (mode . emacs-lisp-mode)
                        (mode . html-mode)
                        (mode . mhtml-mode)
                        (mode . python-mode)
                        (mode . ruby-mode)
                        (mode . scss-mode)
                        (mode . shell-script-mode)
                        (mode . yaml-mode)))
        ("Markdown" (mode . markdown-mode))
        ("Magit" (or
                  (mode . magit-blame-mode)
                  (mode . magit-cherry-mode)
                  (mode . magit-diff-mode)
                  (mode . magit-log-mode)
                  (mode . magit-process-mode)
                  (mode . magit-status-mode)))
        ("Apps" (or
                     (mode . bongo-playlist-mode)
                     (mode . mu4e-compose-mode)
                     (mode . mu4e-headers-mode)
                     (mode . mu4e-main-mode)
                     (mode . elfeed-search-mode)
                     (mode . elfeed-show-mode)
                     (mode . mu4e-view-mode)))
         ("Emacs" (or
                   (name . "^\\*Help\\*$")
                   (name . "^\\*Custom.*")
                   (name . "^\\*Org Agenda\\*$")
                   (name . "^\\*info\\*$")
                   (name . "^\\*scratch\\*$")
                   (name . "^\\*Backtrace\\*$")
                   (name . "^\\*Messages\\*$"))))))
    :config
    (defun prot/ibuffer-multi ()
      "Spawn a new instance of `ibuffer' and give it a unique name
  based on the directory of the current buffer."
      (interactive)
      (let* ((parent (if (buffer-file-name)
                         (file-name-directory (buffer-file-name))
                       default-directory))
             (name (car (last (split-string parent "/" t)))))
        (split-window-sensibly)
        (other-window 1)
        (ibuffer t "*Ibuffer [new]*")
        (rename-buffer (concat "*Ibuffer: " name "*"))))
    :hook
    (ibuffer-mode-hook . (lambda ()
                       (ibuffer-switch-to-saved-filter-groups "Main")))
    :bind (("C-x C-b" . ibuffer)
           ("C-x C-S-b" . prot/ibuffer-multi) ; EXPERIMENTAL
           ))

#+END_SRC

** Emacs "desktop"

Guarda el estado en el que estaba Emacs: nombre, posición de los buffers y similares.

#+begin_src emacs-lisp

  (use-package desktop
    :disabled
    :config
    (setq desktop-dirname user-emacs-directory)
    (setq desktop-base-file-name "desktop")
    (setq desktop-missing-file-warning t)
    (setq desktop-restore-eager 3)
    :hook (after-init-hook . (lambda () (desktop-save-mode 1))))

  #+end_src

** Atajos de teclado imprescindibles

#+begin_src emacs-lisp

  (use-package emacs
      :bind
      (("C-." . repeat)
       ("<C-tab>" . other-window)			; ATENCION: No válido en mac
       ("C-ñ" . other-window)
       ;; ("M-}" . "}")
       ;; ("M-+" . "]")
       ))

#+END_SRC

* exwm: configuración de emacs como window manager

Carga la configuración del Escritorio así como el gestor de ventanas (EXWM) si éste es soportado por el sistema operativo y, además, se pasa el argumento =--use-exwm= en el arranque de Emacs. El código del gestor de ventanas (EXWM) se enecuentra en exwm.org.

#+begin_src emacs-lisp

  (setq ammz/exwm-enabled (and (eq window-system 'x) ; Sólo sistemas con X Window
                             (seq-contains command-line-args "--use-exwm")))

  (when ammz/exwm-enabled
    (require 'ammz-exwm))

#+end_src

** COMMENT Basic configuration

#+begin_SRC emacs-lisp

  (use-package exwm
    :straight t)

  (require 'exwm)
  (require 'exwm-config)

  ;; Set the initial workspace number.
  (setq exwm-workspace-number 5)

  ;; Make class name the buffer name
  (add-hook 'exwm-update-class-hook
            (lambda ()
              (exwm-workspace-rename-buffer exwm-class-name)))

#+end_SRC

** COMMENT Global keys

#+begin_SRC emacs-lisp

  (unless (get 'exwm-input-global-keys 'saved-value)
    (setq exwm-input-global-keys
          '(([?\s-&] . (lambda (command)
                         (interactive (list (read-shell-command "$ ")))
                         (start-process-shell-command command nil command)))

            ;; 's-r': Reset (to line-mode).
            ([?\s-r] . exwm-reset)

            ;; managing workspaces
            ([?\s-w] . exwm-workspace-switch)
            ([?\s-W] . exwm-workspace-swap)
            ([?\s-\C-w] . exwm-workspace-move)

            ;; reset exwm
            ([?\s-r] . exwm-reset)

            ;; managing windows
            ([s-left] . windmove-left)
            ([s-right] . windmove-right)
            ([s-up] . windmove-up)
            ([s-down] . windmove-down)

            ;; swaping windows
            ([s-S-left] . windmove-swap-states-left)
            ([s-S-right] . windmove-swap-states-right)
            ([s-S-up] . windmove-swap-states-up)
            ([s-S-down] . windmove-swap-states-down)

            ;; managing window sizes
            ([s-M-left] . enlarge-window-horizontally)
            ([s-M-right] . shrink-window-horizontally)
            ([s-M-up] . shrink-window)
            ([s-M-down] . enlarge-window)

            ;; Focus window
            ([?\s- ] . other-window)
            ([?\s-1] . select-window-1)
            ([?\s-2] . select-window-2)
            ([?\s-3] . select-window-3)
            ([?\s-4] . select-window-4)
            ([?\s-5] . select-window-5)
            ([?\s-6] . select-window-6)
            ([?\s-7] . select-window-7)
            ([?\s-8] . select-window-8)
            ([s-f11] . ammz/go-previous-workspace)
            ([s-f12] . ammz/go-next-workspace)

            ;; programs
            ([?\s-d] . dmenu)

            ;; Controles de audio
            ([XF86AudioMute] . (lambda () (interactive) (start-process-shell-command "Mute" nil "amixer -q set Master toggle")))
            ([XF86AudioLowerVolume] . (lambda () (interactive) (start-process-shell-command "Decrease" nil "amixer -q set Master 5%-")))
            ([XF86AudioRaiseVolume] . (lambda () (interactive) (start-process-shell-command "Increase" nil "amixer -q set Master 5%+")))
            ([XF86AudioPlay] . (lambda () (interactive) (start-process-shell-command "Play" nil "playerctl play-pause")))
            ([XF86AudioNext] . (lambda () (interactive) (start-process-shell-command "Next" nil "playerctl next")))
            ([XF86AudioPrev] . (lambda () (interactive) (start-process-shell-command "Previous" nil "playerctl previous")))
            ([XF86AudioStop] . (lambda () (interactive) (start-process-shell-command "Stop" nil "playerctl stop")))
            )))

#+end_SRC

** COMMENT Simulation keys

  #+begin_SRC emacs-lisp

  (unless (get 'exwm-input-simulation-keys 'saved-value)
    (setq exwm-input-simulation-keys
          '(([?\C-b] . [left])
            ([?\C-f] . [right])
            ([?\C-p] . [up])
            ([?\C-n] . [down])
            ([?\C-a] . [home])
            ([?\C-e] . [end])
            ([?\M-v] . [prior])
            ([?\C-v] . [next])
            ([?\C-d] . [delete])
            ([?\C-k] . [S-end delete]))))

  #+end_SRC

** COMMENT systemtray

  #+begin_SRC emacs-lisp

  ;; systemtray
  ;; (require 'exwm-systemtray)
  ;; (exwm-systemtray-enable)

  #+end_SRC

** COMMENT Multi-monitors

  #+begin_SRC emacs-lisp

  ;; multi-monitors
  (require 'exwm-randr)
  (setq exwm-randr-workspace-output-plist '(0 "eDP1" 1 "HDMI1"))
  (add-hook 'exwm-randr-screen-change-hook
            (lambda ()
              (start-process-shell-command
               "xrandr" nil "xrandr --output eDP1 --off --output HDMI1 --auto")))
  (exwm-randr-enable)

  #+end_SRC

** COMMENT Enable EXWM

  #+begin_SRC emacs-lisp

  ;; Enable EXWM
  (exwm-enable)

  #+end_SRC

** COMMENT Configure Ido

  #+begin_SRC emacs-lisp

    (require 'ido)

    (defun exwm-config--fix/ido-buffer-window-other-frame ()
      "Fix `ido-buffer-window-other-frame'."
      (defalias 'exwm-config-ido-buffer-window-other-frame
        (symbol-function #'ido-buffer-window-other-frame))
      (defun ido-buffer-window-other-frame (buffer)
        "This is a version redefined by EXWM.

      You can find the original one at `exwm-config-ido-buffer-window-other-frame'."
        (with-current-buffer (window-buffer (selected-window))
          (if (and (derived-mode-p 'exwm-mode)
                   exwm--floating-frame)
              ;; Switch from a floating frame.
              (with-current-buffer buffer
                (if (and (derived-mode-p 'exwm-mode)
                         exwm--floating-frame
                         (eq exwm--frame exwm-workspace--current))
                    ;; Switch to another floating frame.
                    (frame-root-window exwm--floating-frame)
                  ;; Do not switch if the buffer is not on the current workspace.
                  (or (get-buffer-window buffer exwm-workspace--current)
                      (selected-window))))
            (with-current-buffer buffer
              (when (derived-mode-p 'exwm-mode)
                (if (eq exwm--frame exwm-workspace--current)
                    (when exwm--floating-frame
                      ;; Switch to a floating frame on the current workspace.
                      (frame-selected-window exwm--floating-frame))
                  ;; Do not switch to exwm-mode buffers on other workspace (which
                  ;; won't work unless `exwm-layout-show-all-buffers' is set)
                  (unless exwm-layout-show-all-buffers
                    (selected-window)))))))))

    (defun exwm-config-ido ()
      "Configure Ido to work with EXWM."
      (ido-mode 1)
      (add-hook 'exwm-init-hook #'exwm-config--fix/ido-buffer-window-other-frame))

    ;; Configure Ido
    (exwm-config-ido)

  #+end_SRC

** COMMENT Polybar

  #+begin_SRC emacs-lisp

  ;; Polybar
  (defvar ammz/polybar-process nil
    "Guarda el proceso de la instancia Polybar, si existe")

  (defun ammz/kill-panel ()
    (interactive)
    (when ammz/polybar-process
      (ignore-errors
        (kill-process ammz/polybar-process)))
    (setq ammz/polybar-process nil))

  (defun ammz/start-panel ()
    (interactive)
    (ammz/kill-panel)
    (setq ammz/polybar-process (start-process-shell-command "polybar" nil "polybar --reload mainbar-exwm -c ~/.config/polybar/config")))

  (ammz/start-panel)

  #+end_SRC

** COMMENT Selección workspace

  #+begin_SRC emacs-lisp

  (defun ammz/go-next-workspace ()
    "Cambia al siguiente workspace o reinicia desde el 0"
    (interactive)
    (let* ((ws (exwm-workspace--position (selected-frame)))
           (ultimo (- (exwm-workspace--count) 1)))
      (if (< ws ultimo)
          (exwm-workspace-switch (+ ws 1))
        (exwm-workspace-switch 0))

      (if (equal ws ultimo)
          (message "Estamos en el workspace 0")
        (message "Estamos en el workspace %d" (+ ws 1)))))

  (defun ammz/go-previous-workspace ()
    "Cambia al anterior workspace o reinicia desde el último"
    (interactive)
    (let* ((ws (exwm-workspace--position (selected-frame)))
           (ultimo (- (exwm-workspace--count) 1)))
      (if (> ws 0)
          (exwm-workspace-switch (- ws 1))
        (exwm-workspace-switch ultimo))
      (if (equal ws 0)
          (message "Estamos en el workspace %d" ultimo)
      (message "Estamos en el workspace %d" (- ws 1)))))

  #+end_SRC

** COMMENT dmenu

#+begin_SRC emacs-lisp

    (use-package dmenu
      :straight t)

#+end_SRC

* Métodos de búsqueda

** Orderless

#+begin_SRC emacs-lisp
  (use-package orderless
    :straight t
    :demand
    :config
    (setq orderless-component-separator " +")
    ;; (setq orderless-matching-styles prot-orderless-default-styles)
    ;; (setq orderless-style-dispatchers
    ;;       '(prot-orderless-literal-dispatcher
    ;;         prot-orderless-initialism-dispatcher))
    ;; SPC should never complete: use it for `orderless' groups.
    :bind (:map minibuffer-local-completion-map
                ("SPC" . nil)))
#+end_SRC

** Marginalia

#+begin_src emacs-lisp
(use-package marginalia
  :straight t
  :demand
  :config
  (setq marginalia-annotators
        '(marginalia-annotators-heavy
          marginalia-annotators-light))
  (marginalia-mode 1))
#+end_src

** Minibuffer

#+begin_SRC emacs-lisp
(use-package minibuffer
  :demand
  :config
  (setq completion-styles '(orderless partial-completion))
  (setq completion-category-defaults nil)
  (setq completion-cycle-threshold 3)
  (setq completion-flex-nospace nil)
  (setq completion-pcm-complete-word-inserts-delimiters t)
  (setq completion-pcm-word-delimiters "-_./:| ")
  (setq completion-show-help nil)
  (setq completion-ignore-case t)
  (setq-default case-fold-search t)   ; For general regexp

  (setq completions-format 'vertical)

  (setq read-buffer-completion-ignore-case t)
  (setq read-file-name-completion-ignore-case t)

  (setq enable-recursive-minibuffers t)
  (setq read-answer-short t)
  (setq resize-mini-windows t)
  (setq minibuffer-eldef-shorten-default t)

  (file-name-shadow-mode 1)
  (minibuffer-depth-indicate-mode 1)
  (minibuffer-electric-default-mode 1)

  ;; Defines, among others, aliases for common minibuffer commands to
  ;; Super-KEY.  Normally these should go in individual package
  ;; declarations, but their grouping here makes things easier to
  ;; understand.  Besides, they are related to the minibuffer.
  :bind (("s-b" . switch-to-buffer)
         ("s-B" . switch-to-buffer-other-window)
         ("s-f" . find-file)
         ("s-F" . find-file-other-window)
         ("s-d" . dired)
         ("s-D" . dired-other-window)
         :map completion-list-mode-map
         ("n" . next-line)
         ("p" . previous-line)
         ("f" . next-completion)
         ("b" . previous-completion)))
#+end_SRC

** Embark

#+begin_SRC emacs-lisp
  (use-package embark
    :straight t
    :demand
    :diminish embark-collect-zebra-minor-mode
    :config
    (setq embark-collect-initial-view-alist
          '((file . list)
            (buffer . list)
            (symbol . list)
            (line . list)
            (xref-location . list)
            (kill-ring . zebra)
            (t . list)))
    (setq embark-collect-live-update-delay 0.25)
    (setq embark-collect-live-initial-delay 0.5)

    ;; Please don't read too much into the names of those faces.  Just
    ;; green and yellow.
    (setq embark-action-indicator (propertize "Act" 'face 'success))
    (setq embark-become-indicator (propertize "Become" 'face 'warning))

    ;; ;; NOTE: I keep this around for when I do videos, otherwise I do not
    ;; ;; use it.
    (setq embark-action-indicator
          (lambda (map)
            (which-key--show-keymap "Embark" map nil nil 'no-paging)
            #'which-key--hide-popup-ignore-command)
          embark-become-indicator embark-action-indicator)
    :hook ((minibuffer-setup-hook . embark-collect-completions-after-input)
           (embark-post-action-hook . embark-collect--update-linked)
           (embark-collect-mode-hook . hl-line-mode))
    :bind (("C-," . embark-act)
           :map minibuffer-local-completion-map
           ("C-," . embark-act)
           ("C-." . embark-act-noexit)
           ("C->" . embark-become)
           ("M-q" . embark-collect-toggle-view) ; parallel of `fill-paragraph'
           ;; NOTE: to switch to the live collection buffer, I use
           ;; `prot-minibuffer-focus-mini-or-completions' which is bound
           ;; to "s-v".
           :map embark-collect-mode-map
           ("," . embark-act)
           ("." . embark-act-noexit)
           ("M-o" . embark-export)
           ("C-o" . embark-export)
           ("M-t" . toggle-truncate-lines)
           ("M-q" . embark-collect-toggle-view)
           :map embark-symbol-map
           ("." . embark-find-definition)
           ("k" . describe-keymap)))
#+end_SRC

** Consult

#+begin_SRC emacs-lisp
(use-package consult
  :straight t
  :demand
  :config
  (setq consult-line-numbers-widen t)
  (setq completion-in-region-function #'consult-completion-in-region)
  (setq consult-async-input-debounce 0.5)
  (setq consult-async-input-throttle 0.8)
  (setq consult-narrow-key ">")
  (setq consult-widen-key "<")
  :bind (("M-X" . consult-mode-command)
         ("M-s m" . consult-mark)
         :map consult-narrow-map
         ("?" . consult-narrow-help)
         :map minibuffer-local-completion-map
         ("<tab>" . minibuffer-force-complete)))
#+end_SRC

** Dabbrev

#+begin_src emacs-lisp
(use-package dabbrev
  :after minibuffer ; read those as well
  :config
  (setq dabbrev-abbrev-char-regexp "\\sw\\|\\s_")
  (setq dabbrev-abbrev-skip-leading-regexp "[$*/=']")
  (setq dabbrev-backward-only nil)
  (setq dabbrev-case-distinction 'case-replace)
  (setq dabbrev-case-fold-search t)
  (setq dabbrev-case-replace 'case-replace)
  (setq dabbrev-check-other-buffers t)
  (setq dabbrev-eliminate-newlines t)
  (setq dabbrev-upcase-means-case-search t)

  ;; FIXME: this is not reliable
  (defun prot/dabbrev-completion ()
    "Expand current phrase or call `dabbrev-completion'."
    (interactive)
    (let* ((abbrev (dabbrev--abbrev-at-point))
           (ignore-case-p (dabbrev--ignore-case-p abbrev))
           (completion-list (dabbrev--find-all-expansions abbrev ignore-case-p)))
      (cond
       ((when (and (eq completion-list nil)
                   (not (eq last-repeatable-command 'mode-exit)))
          (insert " ")
          (dabbrev-expand 1)))
       (t
        (dabbrev-completion)))))

  :bind (("M-/" . dabbrev-expand)
         ("C-M-/" . prot/dabbrev-completion)
         ("s-/" . prot/dabbrev-completion)))
#+end_src

** Avy

Permite mover el punto a cualquier posición en Emacs usando pocas teclas (C-c s).

#+begin_src emacs-lisp

  (use-package avy
    :straight t
    :bind
    ("C-c s" . avy-goto-char))

#+END_SRC

* Relativo a los lenguajes
** Org-mode

#+begin_src emacs-lisp
  (use-package org
    :straight org-plus-contrib
    :config
    (setq org-startup-indented t)
    (setq org-attach-use-inheritance t)
    (setq org-list-allow-alphabetical t)

    ;; -------------------------------------------------------------------
    ;; agenda
    ;; -------------------------------------------------------------------
    (setq org-agenda-files '("~/Sync/org" "~/Sync/org/etea"))

    ;; agenda en la ventana actual
    (setq org-agenda-window-setup 'current-window)
    ;; avisa de tareas deadline en los próximos 7 días
    (setq org-deadline-warning-days 7)
    ;; muestra tareas scheduled o deadline en los próximos 10 días
    (setq org-agenda-span 10)
    ;; no muestra tareas scheduled si ya tienen fecha deadline
    (setq org-agenda-skip-deadline-if-deadlline-is-shown t)
    ;; no colorea tareas con deadline inminente si ya son scheduled
    (setq org-agenda-skip-deadline-prewarning-if-scheduled 'pre-scheduled)
    ;; no muestra tareas con fecha. implica que también ignora tareas
    ;; scheduled y deadlines
    (setq org-agenda-todo-ignore-with-date t)

    ;; -------------------------------------------------------------------
    ;; capture, refile, todo
    ;; -------------------------------------------------------------------
    (setq org-capture-templates
          '(("o" "TODO vencimiento" entry
             (file+headline "~/Sync/org/inbox.org" "tareas")
             "* TODO %?\nDEADLINE: %^{fecha tope}t")
            ("t" "TODO" entry
             (file+headline "~/Sync/org/inbox.org" "tareas")
             "* TODO %?\n")
            ("n" "Nota" entry
             (file+headline "~/Sync/org/inbox.org" "notas")
             "* %?\n%c")
            ("h" "Nota alerta" entry
             (file+headline "~/proyectos/hugo-sge/content-org/pie.org" "notas de alerta")
             (function org-hugo-new-subtree-post-capture-template)
             :prepend t)
            ("r" "Recordatorio" entry
             (file "~/Sync/org/recuerda.org")
             "* %?\n %^t")
            ("d" "Diario" entry
             (file+olp+datetree "~/Sync/org/diario.org")
             "** %?" :time-prompt t)
            ("R" "Reunion" entry
             (file+headline "~/Sync/org/inbox.org" "reuniones")
             "* TODO %? :reunion:\n%^t %^{lugar}p")
            ("i" "Informe" entry
             (file+headline "~/Sync/org/informes.org" "2019")
             "* TODO %? %^g\n:PROPERTIES:\n
                             :solicitante: %^{solicitante|sge|sgt|vice}\n
                             :f_entrada: %^u\n
                             :f_respuesta: \n:end:\n")))

    ;; Scanea los target de refile en los archivos de la agenda. Aumenta
    ;; los niveles en los que encontrar posibles encabezamientos para
    ;; reasignar tareas. Por defecto son sólo 3.
    (setq org-refile-targets (quote ((nil :maxlevel . 6)
                                     (org-agenda-files :maxlevel . 6))))

    ;; Establece como archivar los ficheros org
    (setq org-archive-location "archivador/%s_archive::")

    (setq org-todo-keywords
          '((sequence "TODO" "NEXT" "WAITING" "|" "DONE" "CANCEL")))

    ;; -------------------------------------------------------------------
    ;; exportar
    ;; -------------------------------------------------------------------
    (setq org-export-default-language "es")
    (setq org-export-date-timestamp-format "%d de %b %y")

    ;; -------------------------------------------------------------------
    ;; icalendar
    ;; -------------------------------------------------------------------
    (setq org-icalendar-combined-agenda-file "/library/webserver/documents/org.ics")
    (setq org-icalendar-store-uid t)
    (setq org-icalendar-include-todo t)
    (setq org-icalendar-use-deadline '(event-if-todo))
    (setq org-icalendar-use-scheduled '(event-if-todo))

    ;; -------------------------------------------------------------------
    ;; latex
    ;; -------------------------------------------------------------------
    (setq org-latex-pdf-process '("latexmk -lualatex"))
    (setq org-latex-packages-alist
          '(("auto" "polyglossia" t ("xelatex" "lualatex"))
            ("" "fontspec" nil ("xelatex" "lualatex"))
            ("" "unicode-math" nil ("xelatex" "lualatex"))))
    (setq org-latex-clasess
          '(("article" "\\documentclass[12pt,a4paper]{article}"
             ("\\section{%s}" . "\\section*{%s}")
             ("\\subsection{%s}" . "\\subsection*{%s}")
             ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
             ("\\paragraph{%s}" . "\\paragraph*{%s}")
             ("\\subparagraph{%s}" . "\\subparagraph*{%s}"))
            ("report" "\\documentclass[12pt,a4paper]{report}"
             ("\\part{%s}" . "\\part*{%s}")
             ("\\chapter{%s}" . "\\chapter*{%s}")
             ("\\section{%s}" . "\\section*{%s}")
             ("\\subsection{%s}" . "\\subsection*{%s}")
             ("\\subsubsection{%s}" . "\\subsubsection*{%s}"))
            ("book" "\\documentclass[12pt,a4paper]{book}"
             ;; ("\\part{%s}" . "\\part*{%s}")
             ("\\chapter{%s}" . "\\chapter*{%s}")
             ("\\section{%s}" . "\\section*{%s}")
             ("\\subsection{%s}" . "\\subsection*{%s}")
             ("\\subsubsection{%s}" . "\\subsubsection*{%s}"))))

    ;; -------------------------------------------------------------------
    ;; codigo
    ;; -------------------------------------------------------------------
    ;; Ejecuta bloques de código sin pedir confirmación
    (setq org-confirm-babel-evaluate nil)
    ;; Ejecuta los bloques de código al salvar el archivo
    (add-hook 'after-save-hook 'org-babel-tangle)

    ;; -------------------------------------------------------------------
    ;; general
    ;; -------------------------------------------------------------------
    (setq org-structure-template-alist
          '(("s" . "SRC")
            ("e" . "SRC emacs-lisp")
            ("E" . "EXAMPLE")
            ("q" . "QUOTE")
            ("v" . "VERSE")
            ("V" . "VERBATIM")
            ("c" . "CENTER")
            ("C" . "COMMENT")))

    (setq org-ellipsis " »")

    (org-babel-do-load-languages
     'org-babel-load-languages
     '((emacs-lisp . t)
       (python . t)
       (shell . t)
       (R . t)
       (calc . t)
       (gnuplot . t)
       (haskell . t)
       (latex . t)
       (org . t)
       (js . t)
       (java . t)
       (makefile . t)
       (C . t)))

    ;; -------------------------------------------------------------------
    ;; org link
    ;; -------------------------------------------------------------------
    (add-to-list 'org-file-apps '("\\.odt?\\'" . "open %s"))
    (add-to-list 'org-file-apps '("\\.ods?\\'" . "open %s"))
    (add-to-list 'org-file-apps '("\\.docx?\\'" . "open %s"))

    ;; añade un tipo de link para que emacs abra el fichero en Curio
    (defun open-curio (path)
      (shell-command (concat "open -a /Applications/Curio.app '" path "'")))
    (org-add-link-type "curio" 'open-curio)

    :bind
    (("C-c a" . org-agenda)
     ("C-c c" . org-capture)
     ("C-c b" . org-switchb)
     ("C-c t" . org-toggle-link-display)
     ("C-c l" . org-store-link))

    :hook
    ((org-mode-hook . (lambda () (visual-line-mode)))
     (org-mode-hook . (lambda () (scroll-bar-mode -1)))))


  (use-package org-mac-link
    :after org
    :hook
    (org-mode-hook . (lambda ()
                       (define-key org-mode-map
                         (kbd "C-c g") 'org-mac-grab-link))))

  (use-package ob-async
    :straight t)

  (use-package org-tempo
    :after org)

  (require 'org-inlinetask)

  ;; Permite utilizar la etiqueta 'ignore' para evitar exportar
  ;; el encabezado pero no el contenido
  (require 'ox-extra)
  (ox-extras-activate '(ignore-headlines))

  ;; Permite que las exportaciones se guarden en directorios diferentes
  ;; (export_html, export_odt, etc) según el tipo de fichero a obtener
  (defvar org-export-output-directory-prefix
    "export_" "prefix of directory used for org-mode export")

  (defadvice org-export-output-file-name (before org-add-export-dir activate)
    "Modifies org-export to place exported files in a different directory"
    (when (not pub-dir)
      (setq pub-dir (concat org-export-output-directory-prefix (substring extension 1)))
      (when (not (file-directory-p pub-dir))
        (make-directory pub-dir))))

  ;; El nombre el fichero exportado incorpora la fecha de exportación
  (defun modi/org-advice-prefix-export-file-name-with-date (orig-fun &rest args)
    "Prefix the output file name with current date."
    (let* ((date-format "%Y-%m-%d")       ;Customize this variable as you like
           (date-file-separator "-")      ;Customize this variable as you like
           (orig-output-file-name (apply orig-fun args))
           (orig-output-dir (file-name-directory orig-output-file-name))
           (orig-output-just-file-name (file-name-nondirectory orig-output-file-name))
           (date (format-time-string date-format (current-time))))
      (concat orig-output-dir date date-file-separator orig-output-just-file-name)))
  (advice-add 'org-export-output-file-name :around #'modi/org-advice-prefix-export-file-name-with-date)
#+END_SRC

** COMMENT org-roam

#+begin_src emacs-lisp

  (use-package org-roam
    :disabled
    :ensure org-roam
    :disabled t
    :hook
    (after-init-hook . org-roam-mode)
    :custom
    ;(org-roam-directory "~/Sync/org/planes/")
    :bind (:map org-roam-mode-map
                (("C-c n l" . org-roam)
                 ("C-c n f" . org-roam-find-file)
                 ("C-c n g" . org-roam-show-graph))
                :map org-mode-map
                (("C-c n i" . org-roam-insert))))

#+end_SRC
** ox-hugo

#+begin_src emacs-lisp

  (use-package ox-hugo
    :straight t
    :config
    (with-eval-after-load 'ox
      (require 'ox-hugo))
    )

#+end_SRC

Plantilla para capturar nueva entrada

#+begin_src emacs-lisp

  (defun org-hugo-new-subtree-post-capture-template ()
    "Returns `org-capture' template string for new Hugo post.
  See `org-capture-templates' for more information."
    (let* (;; http://www.holgerschurig.de/en/emacs-blog-from-org-to-hugo/
           (date (format-time-string (org-time-stamp-format :long :inactive) (org-current-time)))
           (title (read-from-minibuffer "Post Title: ")) ;Prompt to enter the post title
           (fname (org-hugo-slug title)))
      (mapconcat #'identity
                 `(
                   ,(concat "* " title)
                   ":PROPERTIES:"
                   ,(concat ":EXPORT_HUGO_BUNDLE: " fname)
                   ,(concat ":EXPORT_DATE: " date) ;Enter current date and time
                   ":END:"
                   "#+begin_src yaml :front_matter_extra t"
                   "portada: 's'"
                   "resources:"
                   "  - src: "
                   "#+end_src"
                   "%?\n")                ;Place the cursor here finally
                 "\n")))

#+end_SRC
** gnuplot

#+begin_src emacs-lisp

  (use-package gnuplot
    :straight t
    )

#+end_SRC

** IDE (lsp)

*** lsp-mode

#+begin_SRC emacs-lisp

  (defun efs/lsp-mode-setup ()
    (setq lsp-headerline-breadcrumb-segments '(path-up-to-project file symbols))
    (lsp-headerline-breadcrumb-mode))

  (use-package lsp-mode
    :commands (lsp lsp-deferred)
    :hook (lsp-mode-hook . efs/lsp-mode-setup)
    :init
    (setq lsp-keymap-prefix "C-c l")
    :config
    (setq lsp-enable-which-key-integration t))

#+end_SRC

*** lsp-ui

#+begin_SRC emacs-lisp

  (use-package lsp-ui
    :straight t
    :hook (lsp-mode-hook . lsp-ui-mode)
    :custom
    (lsp-ui-doc-position 'bottom))

#+end_SRC

*** lsp-treemacs

#+begin_SRC emacs-lisp

  (use-package lsp-treemacs
    :straight t
    :after lsp)

#+end_SRC

** Debugging DAP mode

#+begin_SRC emacs-lisp

  (use-package dap-mode
    :straight t)

#+end_SRC

** ESS
#+begin_SRC emacs-lisp

  (use-package ess
    :straight t
    )

#+end_SRC
** C++

Modern C++ code highlighting

#+begin_src emacs-lisp

  (use-package modern-cpp-font-lock
    :straight t
    :init
    (eval-when-compile
      ;; Silence missing function warnings
      (declare-function modern-c++-font-lock-global-mode
                        "modern-cpp-font-lock.el"))
    :config
    (modern-c++-font-lock-global-mode t)
    )

#+end_SRC

Cofiguramos cc-mode

#+begin_src emacs-lisp

  (defvar my:compile-command "g++ -std=c++11")
  (use-package cc-mode
    :init
    (add-to-list 'auto-mode-alist '("\\.tpp\\'" . c++-mode))
    (add-to-list 'auto-mode-alist '("\\.h\\'" . c++-mode))
    (add-to-list 'auto-mode-alist '("\\.hpp\\'" . c++-mode))
    (add-to-list 'auto-mode-alist '("\\.cpp\\'" . c++-mode))
    :config
    (define-key c++-mode-map (kbd "C-c C-c") 'compile)
    (define-key c++-mode-map (kbd "C-c C-k") 'kill-compilation)
    (setq compile-command my:compile-command)

    (use-package google-c-style
      :straight t
      :config
      ;; This prevents the extra two spaces in a namespace that Emacs
      ;; otherwise wants to put... Gawd!
      (add-hook 'c-mode-common-hook 'google-set-c-style)
      ;; Autoindent using google style guide
      (add-hook 'c-mode-common-hook 'google-make-newline-indent)
      )
    )

#+end_SRC

** Haskell

#+begin_SRC emacs-lisp
  (use-package haskell-mode
    :straight t)
#+end_SRC

** Python

La principal herramienta que uso para trabajar con python es Elpy.

#+begin_src emacs-lisp

  (use-package elpy
    :straight t
    :init
    (elpy-enable)
    :hook (python-mode-hook . lsp-deferred))

#+end_SRC

** Html

#+begin_src emacs-lisp

  (use-package web-mode
    :straight t
    :mode ("\\.html$" . web-mode)
    )

#+end_SRC

** Php

#+begin_src emacs-lisp

  (use-package php-mode
    :straight t
    :mode ("\\.php$" . php-mode)
    :init
    (setq php-mode-coding-style (quote psr2))
    (setq php-search-documentation-browser-function 'eww-browse-url)
    (setq php-style-delete-trailing-whitespace 1)
    )

#+end_SRC

** Typoscript

#+begin_src emacs-lisp

  (use-package typoscript-mode
    :straight
    :mode ("\\.typoscript" . typoscript-mode))

#+end_SRC

** Tex - LaTeX - ConTeXt - AucTex

#+begin_src emacs-lisp

  (use-package tex
    :straight auctex
    :custom
    (TeX-auto-save t)
    (TeX-parse-self t)
    :config
    (setq-default TeX-master nil)
    (setq-default TeX-engine 'luatex)
    (add-hook 'TeX-mode-hook
          (lambda ()
            (local-set-key (kbd "º") "\\"))) ;muy útil para LaTeX
    )

#+END_SRC

*** ConTeXt

Usamos siempre Mark IV que ejecuta ConTeXt sobre el motor LuaTeX en vez de PDFTeX o XeTeX

#+begin_src emacs-lisp

  (setq ConTeXt-Mark-version "IV")

#+END_SRC

Para mejorar la visualización

#+begin_src emacs-lisp

  (add-hook 'TeX-mode-hook  #'visual-line-mode)
  ;; (add-hook 'TeX-mode-hook '(lambda () (switch-theme 'material)))

#+END_SRC

Configuración sugerida en http://wiki.contextgarden.net/AUCTeX

**** Ayuda con delimitadores y math mode

#+begin_src emacs-lisp

  ;;; Useful AUCTeX setup for ConTeXt (for your .emacs)
  ;;; Sanjoy Mahajan (sanjoy@mrao.cam.ac.uk), 2006-04-20.  No copyright.
  ;;;
  ;;; With recent AUCTeX (11.50 or later), editing ConTeXt files should
  ;;; just work, but I use the following elisp as well.

  ; the AUCTeX manual recommends these settings (ya configurado más arriba)
  ;(setq TeX-parse-self t)			; Enable parse on load.
  ;(setq TeX-auto-save t)			; Enable parse on save.

  ; for outline views (hide/show sections, chapters, etc.)
  (add-hook 'TeX-mode-hook '(lambda () (TeX-fold-mode 1)))
  (add-hook 'TeX-mode-hook '(lambda () (outline-minor-mode 1)))
  ; make PDF by default (can toggle with C-c C-t C-p
  (add-hook 'TeX-mode-hook '(lambda () (TeX-PDF-mode 1)))
  ; these math abbrevs (` as prefix char) are also useful in TeX/ConTeXt files
  (require 'latex)			; defines LaTeX-math-mode
  (add-hook 'TeX-mode-hook 'LaTeX-math-mode)
  ; Emacs help for \label, \ref, \cite.  Normally used only with
  ; LaTeX-mode but also useful with plain TeX + eplain and with ConTeXt, so:
  (setq reftex-plug-into-AUCTeX t)
  (add-hook 'TeX-mode-hook 'reftex-mode)

  ;; (defun insert-balanced (left right)
  ;;   "Insert a left, right delimiter pair and be poised to type inside them."
  ;;   (interactive)
  ;;   (insert left)
  ;;   (save-excursion
  ;;     (insert right)))

  ; When star
  ; t-context-math() is bound to $:
  ; Typing one $ gets you $$ with the insertion point between them.
  ; Typing a second $ turns the $$ into ConTeXt's form for displayed math:
  ;
  ;   \placeformula\startformula
  ;   [blank line with insertion point at beginning]
  ;   \stopformula
  ;
  ; Delete the \placeformula if you don't want equations numbered automatically.

  ;; (defun start-context-math ()
  ;;   (interactive)
  ;;   (let* ((start (max (point-min) (- (point) 1)))
  ;;          (stop  (min (point-max) (+ (point) 1))))
  ;;     ; if in the middle of a $$, turn inline math into context display math
  ;;     (if (equal "$$" (buffer-substring-no-properties start stop))
  ;;         (progn
  ;;           (delete-region start stop)	;get rid of the $$
  ;;           ; delete preceding spaces, if any
  ;;           (while (and (< (point-min) (point))
  ;;                       (equal (buffer-substring-no-properties (- (point) 1)
  ;;                                                              (point))
  ;;                              " "))
  ;;             (backward-delete-char 1))
  ;;           ; delete a preceding newline, if any
  ;;           (if (equal (buffer-substring-no-properties (- (point) 1)
  ;;                                                      (point))
  ;;                      "\n")
  ;;             (backward-delete-char 1))
  ;;           ; ConTeXt's display math with automatic equation numbering
  ;;           (insert "\n\\startformula\n")
  ;;           (save-excursion (insert "\n\\stopformula")))
  ;;       ; else: just doing inline math
  ;;       (insert-balanced ?\$ ?\$))))

  ;; ; automatically insert right delimiter for $, {, [, and ( and be
  ;; ; poised to type inside them.
  ;; (add-hook 'TeX-mode-hook
  ;;           '(lambda ()
  ;;              (local-set-key "$"
  ;;                             '(lambda ()
  ;;                                (interactive)
  ;;                                (insert-balanced ?\$ ?\$)))
  ;;              (local-set-key "{"
  ;;                             '(lambda ()
  ;;                                (interactive)
  ;;                                (insert-balanced ?\{ ?\})))
  ;;              (local-set-key "["
  ;;                             '(lambda ()
  ;;                                (interactive)
  ;;                                (insert-balanced ?\[ ?\])))
  ;;              (local-set-key "("
  ;;                             '(lambda ()
  ;;                                (interactive)
  ;;                                (insert-balanced ?\( ?\))))))

  ;; ; For ConTeXt mode, inserting two $ signs needs to behave specially
  ;; (add-hook 'ConTeXt-mode-hook
  ;;           '(lambda ()
  ;;              (local-set-key "$" 'start-context-math)))

  ;; ; The TeX-format-list from AUCTeX's tex.el (v11.82) with a few more
  ; ConTeXt-specific patterns.  I've submitted it to the AUCTeX lists,
  ; so later versions should have them automatically and you won't need
  ; this regexp mess in your .emacs
  ;
  (setq TeX-format-list
    '(("JLATEX" japanese-latex-mode
       "\\\\\\(documentstyle\\|documentclass\\)[^%\n]*{\\(j[s-]?\\|t\\)\\(article\\|report\\|book\\|slides\\)")
      ("JTEX" japanese-plain-tex-mode
       "-- string likely in Japanese TeX --")
      ("AMSTEX" ams-tex-mode
       "\\\\document\\b")
      ("CONTEXT" context-mode
       "\\(\\\\\\(start\\(text\\|project\\|environment\\|product\\|typing\\|component\\|tekst\\)\\)\\|%.*?interface=\\)")
      ("LATEX" latex-mode
       "\\\\\\(begin\\|section\\|chapter\\|documentstyle\\|documentclass\\)\\b")
      ("TEX" plain-tex-mode ".")))

#+END_SRC

**** Ayuda con natural tables

#+begin_src emacs-lisp

  (defun context-insert-nattab (rows columns)
    ;; Johan Sandblom 2006-01-28
    "Insert a TABLE skeleton"
    (interactive "nNumber of rows: \nnNumber of columns: \n")
    (newline)
    (insert "\\bTABLE\n\\setupTABLE\[\]\n")
    ;; First a TABLE header
    (insert "\\bTABLEhead\n\\bTR\\bTH \\eTH\n")
    (let ((column 1))
      (while (< column (- columns 1))
        (insert "    \\bTH \\eTH\n")
        (setq column (1+ column))))
    (insert "    \\bTH \\eTH\\eTR\n\\eTABLEhead\n\\bTABLEbody\n")
    ;; The rows and columns
    (let ((row 1))
      (while (<= row rows)
        (insert "\\bTR\\bTD \\eTD\n")
        ;; The let expression makes sure that each loop starts at the
        ;; right place
        (let ((column 1))
          (while (< column (- columns 1))
            (insert "    \\bTD \\eTD\n")
            (setq column (1+ column)))
          (insert "    \\bTD \\eTD\\eTR\n")
          (setq row (1+ row))))
      (insert "\\eTABLEbody\n\\eTABLE\n")))

  (defun context-insert-nattab-row (columns)
   "Insert a row in a TABLE"
   (interactive "nNumber of columns: \n")
   (newline)
   (insert "\\bTR\\bTD \\eTD\n")
   (let ((column 1))
     (while (< column (- columns 1))
       (insert "    \\bTD \\eTD\n")
       (setq column (1+ column)))
     (insert "    \\bTD \\eTD\\eTR\n")))

  (defun context-insert-nattab-column (&optional arg)
   "Insert a column in a TABLE"
   (interactive "P")
   (insert "\\bTD \\eTD")
   (indent-for-tab-command)
   (newline)
   (backward-char 5))



  (add-hook 'ConTeXt-mode-hook
           '(lambda ()
              (local-set-key "\C-cnr" 'context-insert-nattab-row)
              (local-set-key "\C-cnc" 'context-insert-nattab-column)
              (local-set-key "\C-cnn" 'context-insert-nattab)))

#+END_SRC

** Markdown

#+begin_src emacs-lisp

  (use-package markdown-mode
    :straight
    :config
    (setq markdown-fontify-code-blocks-natively t)
    :mode ("\\.md$" . markdown-mode))

#+end_SRC

** YAML

#+begin_src emacs-lisp

  (use-package yaml-mode
    :straight
    :mode (("\\.yml$" . yaml-mode)
           ("\\.yaml$" . yaml-mode)))

#+end_SRC

** CSS

#+begin_src emacs-lisp

  (use-package css-mode
    :config
    (setq css-fontify-colors nil))

#+end_SRC

** Yasnippets

#+begin_src emacs-lisp

  (use-package yasnippet
    :straight t
    :config
    (yas-reload-all)
    (yas-global-mode))

#+end_SRC

#+begin_src emacs-lisp

  (use-package yasnippet-snippets
    :straight t)

#+end_SRC

** EditorConfig

#+begin_src emacs-lisp

  (use-package editorconfig
    :straight t
    :config
    (editorconfig-mode 1))

#+end_SRC

* Interfaz e interacciones con Emacs

** Linea de edición iluminada

#+begin_src emacs-lisp

  (use-package hl-line
    :config
    (setq global-hl-line-mode t))

#+end_SRC
** Reconocimiento de subpalabras

Altera la forma en la que Emacs entiende los límites de las palabras. Así, /camelCaseWords/ se dividen en sus partes en vez de en una sola palabra.

#+begin_src emacs-lisp

  (use-package subword
    :delight
    :hook (prog-mode-hook . subword-mode))

#+end_SRC
** Auto-fill (texto plano y comentarios)

#+begin_src emacs-lisp

  (use-package emacs
    :hook (text-mode-hook . (lambda ()
                         ;; (turn-on-auto-fill)
                         (delight 'auto-fill-function nil t)
                         (setq adaptive-fill-mode t))))

#+end_SRC
** Paréntesis

Destaca los paréntesis emparentados entre sí.

#+begin_src emacs-lisp

  (use-package paren
    :custom
    (show-paren-style 'mixed)
    (show-paren-when-point-in-periphery t)
    (show-paren-when-point-inside-paren t)
    :config
    (show-paren-mode 1))

#+end_SRC

** Inserta signos de apertura y cierre ('electric')

#+begin_src emacs-lisp

  (use-package electric
    :custom
    (electric-pair-inhibit-predicate 'electric-pair-default-inhibit)
    (electric-pair-skip-self 'electric-pair-default-skip-self)
    (electric-quote-context-sensitive t)
    (electric-quote-paragraph nil)
    (electric-quote-string nil)
    :config
    (electric-indent-mode 1)
    (electric-pair-mode 1))

#+end_SRC

** Tabs e indentación

#+begin_src emacs-lisp

  (use-package emacs
    :init
    (setq-default tab-always-indent 'complete)
    (setq-default tab-width 4))

#+end_SRC

Para c/c++

#+begin_src emacs-lisp

  (use-package emacs
    :custom
    (c-default-style "bsd")
    (c-basic-offset 4))

#+end_SRC

** Longitud de la línea (column count)

#+begin_src emacs-lisp

  (use-package emacs
    :custom
    (fill-column 72)
    (sentence-end-double-space t)
    (sentence-end-without-period nil)
    (colon-double-space nil)
    :config
    (column-number-mode 1))

#+end_SRC

** Borrado de espacios en blanco al final

Provoca innecesarios diff en git. Se borran al guardar.

#+begin_src emacs-lisp

  (use-package emacs
    :hook (before-save-hook . delete-trailing-whitespace))

#+end_SRC

** Comportamiento del scroll

Ahora no recentra el cursor al llegar a los límites superior e inferior

#+begin_src emacs-lisp

  (use-package emacs
    :config
    (setq scroll-preserve-screen-position t)
    (setq scroll-conservatively 1)
    (setq scroll-margin 0))

#+end_SRC

** Números de líneas / Caracteres invisibles

#+begin_src emacs-lisp

  (use-package emacs
    :config
    (defun prot/toggle-line-numbers ()
      "Toggles the display of line numbers.  Applies to all buffers."
      (interactive)
      (if (bound-and-true-p display-line-numbers-mode)
          (display-line-numbers-mode -1)
        (display-line-numbers-mode)))

    (defun prot/toggle-invisibles ()
      "Toggles the display of indentation and space characters."
      (interactive)
      (if (bound-and-true-p whitespace-mode)
          (whitespace-mode -1)
        (whitespace-mode)))
    :bind (("<f7>" . prot/toggle-line-numbers)
           ("<f8>" . prot/toggle-invisibles)))

#+end_SRC

** Which key (sugerencias de teclas)

Es necesario activar el comando manualmente pulsando =C-h= tras comenzar la secuencia (p.e. =C-x C-k C-h=).

#+begin_src emacs-lisp

  (use-package which-key
    :straight t
    :delight
    :config
    (setq which-key-show-early-on-C-h t)
    (setq which-key-idle-delay 10000)
    (setq which-key-idle-secondary-delay 0.05)
    (setq which-key-popup-type 'side-window)
    (setq which-key-show-prefix 'echo)
    (setq which-key-max-display-columns 3)
    (setq which-key-separator " ")
    (setq which-key-special-keys '("SPC" "TAB" "RET" "ESC" "DEL"))
    (which-key-mode 1))

#+end_SRC

* Calendario y agenda en español

#+begin_src emacs-lisp

  (use-package emacs
    :custom
    (system-time-locale (getenv "LANG")))

  (use-package parse-time
    :custom
    (parse-time-months '(("ene" . 1) ("feb" . 2) ("mar" . 3)
                         ("abr" . 4) ("may" . 5) ("jun" . 6)
                         ("jul" . 7) ("ago" . 8) ("sep" . 9)
                         ("oct" . 10) ("nov" . 11) ("dic" . 12)
                         ("enero" . 1) ("febrero" . 2)
                         ("marzo" . 3) ("abril" . 4) ("junio" . 6)
                         ("julio" . 7) ("agosto" . 8)
                         ("septiembre" . 9) ("octubre" . 10)
                         ("noviembre" . 11) ("diciembre" . 12)))
    (parse-time-weekdays '(("dom" . 0) ("lun" . 1) ("mar" . 2)
                           ("mié" . 3) ("jue" . 4) ("vie" . 5)
                           ("sáb" . 6) ("domingo" . 0) ("lunes" . 1)
                           ("martes" . 2) ("miércoles" . 3)
                           ("jueves" . 4) ("viernes" . 5)
                           ("sábado" . 6))))

  (use-package calendar
    :custom
    (calendar-week-start-day 1)
    (calendar-day-name-array ["Domingo" "Lunes" "Martes" "Miércoles"
                              "Jueves" "Viernes" "Sábado"])
    (calendar-day-abbrev-array ["Dom" "Lun" "Mar" "Mié" "Jue" "Vie" "Sáb"])
    (calendar-day-header-array ["Do" "Lu" "Ma" "Mi" "Ju" "Vi" "Sá"])
    (calendar-month-name-array ["Enero" "Febrero" "Marzo" "Abril" "Mayo"
                                "Junio" "Julio" "Agosto" "Septiembre"
                                "Octubre" "Noviembre" "Diciembre"])
    (calendar-month-abbrev-array ["Ene" "Feb" "Mar" "Abr" "May" "Jun"
                                  "Jul" "Ago" "Sep" "Oct" "Nov" "Dic"]))

#+END_SRC
